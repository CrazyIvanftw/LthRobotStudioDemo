// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace abb.egmri {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Egmri {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriHeader__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriHeader, global::abb.egmri.EgmriHeader.Builder> internal__static_abb_egmri_EgmriHeader__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriCartesian__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriCartesian, global::abb.egmri.EgmriCartesian.Builder> internal__static_abb_egmri_EgmriCartesian__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriQuaternion__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriQuaternion, global::abb.egmri.EgmriQuaternion.Builder> internal__static_abb_egmri_EgmriQuaternion__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriPose__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriPose, global::abb.egmri.EgmriPose.Builder> internal__static_abb_egmri_EgmriPose__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriJoints__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriJoints, global::abb.egmri.EgmriJoints.Builder> internal__static_abb_egmri_EgmriJoints__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriJointSpace__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriJointSpace, global::abb.egmri.EgmriJointSpace.Builder> internal__static_abb_egmri_EgmriJointSpace__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriFeedback__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriFeedback, global::abb.egmri.EgmriFeedback.Builder> internal__static_abb_egmri_EgmriFeedback__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriPlanned__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriPlanned, global::abb.egmri.EgmriPlanned.Builder> internal__static_abb_egmri_EgmriPlanned__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriPIDParameters__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriPIDParameters, global::abb.egmri.EgmriPIDParameters.Builder> internal__static_abb_egmri_EgmriPIDParameters__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriMotorState__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriMotorState, global::abb.egmri.EgmriMotorState.Builder> internal__static_abb_egmri_EgmriMotorState__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriMCIState__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriMCIState, global::abb.egmri.EgmriMCIState.Builder> internal__static_abb_egmri_EgmriMCIState__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriRapidCtrlExecState__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriRapidCtrlExecState, global::abb.egmri.EgmriRapidCtrlExecState.Builder> internal__static_abb_egmri_EgmriRapidCtrlExecState__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriTestSignals__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriTestSignals, global::abb.egmri.EgmriTestSignals.Builder> internal__static_abb_egmri_EgmriTestSignals__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriRobot__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriRobot, global::abb.egmri.EgmriRobot.Builder> internal__static_abb_egmri_EgmriRobot__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_abb_egmri_EgmriSensor__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriSensor, global::abb.egmri.EgmriSensor.Builder> internal__static_abb_egmri_EgmriSensor__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Egmri() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgtlZ21yaS5wcm90bxIJYWJiLmVnbXJpItMBCgtFZ21yaUhlYWRlchINCgVz", 
            "ZXFubxgBIAEoDRIKCgJ0bRgCIAEoDRJECgVtdHlwZRgDIAEoDjIiLmFiYi5l", 
            "Z21yaS5FZ21yaUhlYWRlci5NZXNzYWdlVHlwZToRTVNHVFlQRV9VTkRFRklO", 
            "RUQiYwoLTWVzc2FnZVR5cGUSFQoRTVNHVFlQRV9VTkRFRklORUQQABITCg9N", 
            "U0dUWVBFX0NPTU1BTkQQARIQCgxNU0dUWVBFX0RBVEEQAhIWChJNU0dUWVBF", 
            "X0NPUlJFQ1RJT04QAyIxCg5FZ21yaUNhcnRlc2lhbhIJCgF4GAEgAigCEgkK", 
            "AXkYAiACKAISCQoBehgDIAIoAiJBCg9FZ21yaVF1YXRlcm5pb24SCgoCdTAY", 
            "ASACKAISCgoCdTEYAiACKAISCgoCdTIYAyACKAISCgoCdTMYBCACKAIiaQoJ", 
            "RWdtcmlQb3NlEisKCHBvc2l0aW9uGAEgASgLMhkuYWJiLmVnbXJpLkVnbXJp", 
            "Q2FydGVzaWFuEi8KC29yaWVudGF0aW9uGAIgASgLMhouYWJiLmVnbXJpLkVn", 
            "bXJpUXVhdGVybmlvbiIdCgtFZ21yaUpvaW50cxIOCgZqb2ludHMYASADKAIi", 
            "aQoPRWdtcmlKb2ludFNwYWNlEiYKBmpvaW50cxgBIAEoCzIWLmFiYi5lZ21y", 
            "aS5FZ21yaUpvaW50cxIuCg5leHRlcm5hbEpvaW50cxgCIAEoCzIWLmFiYi5l", 
            "Z21yaS5FZ21yaUpvaW50cyLQAQoNRWdtcmlGZWVkYmFjaxIrCg1jYXJ0ZXNp", 
            "YW5Qb3NlGAEgASgLMhQuYWJiLmVnbXJpLkVnbXJpUG9zZRIxCg1qb2ludFBv", 
            "c2l0aW9uGAIgASgLMhouYWJiLmVnbXJpLkVnbXJpSm9pbnRTcGFjZRIuCgpq", 
            "b2ludFNwZWVkGAMgASgLMhouYWJiLmVnbXJpLkVnbXJpSm9pbnRTcGFjZRIv", 
            "Cgtqb2ludFRvcnF1ZRgEIAEoCzIaLmFiYi5lZ21yaS5FZ21yaUpvaW50U3Bh", 
            "Y2UingEKDEVnbXJpUGxhbm5lZBIrCg1jYXJ0ZXNpYW5Qb3NlGAEgASgLMhQu", 
            "YWJiLmVnbXJpLkVnbXJpUG9zZRIxCg1qb2ludFBvc2l0aW9uGAIgASgLMhou", 
            "YWJiLmVnbXJpLkVnbXJpSm9pbnRTcGFjZRIuCgpqb2ludFNwZWVkGAMgASgL", 
            "MhouYWJiLmVnbXJpLkVnbXJpSm9pbnRTcGFjZSKMAQoSRWdtcmlQSURQYXJh", 
            "bWV0ZXJzEiYKAmtwGAEgASgLMhouYWJiLmVnbXJpLkVnbXJpSm9pbnRTcGFj", 
            "ZRImCgJrdhgCIAEoCzIaLmFiYi5lZ21yaS5FZ21yaUpvaW50U3BhY2USJgoC", 
            "a2kYAyABKAsyGi5hYmIuZWdtcmkuRWdtcmlKb2ludFNwYWNlIpIBCg9FZ21y", 
            "aU1vdG9yU3RhdGUSOAoFc3RhdGUYASACKA4yKS5hYmIuZWdtcmkuRWdtcmlN", 
            "b3RvclN0YXRlLk1vdG9yU3RhdGVUeXBlIkUKDk1vdG9yU3RhdGVUeXBlEhQK", 
            "EE1PVE9SU19VTkRFRklORUQQABINCglNT1RPUlNfT04QARIOCgpNT1RPUlNf", 
            "T0ZGEAIiqAEKDUVnbXJpTUNJU3RhdGUSQwoFc3RhdGUYASACKA4yJS5hYmIu", 
            "ZWdtcmkuRWdtcmlNQ0lTdGF0ZS5NQ0lTdGF0ZVR5cGU6DU1DSV9VTkRFRklO", 
            "RUQiUgoMTUNJU3RhdGVUeXBlEhEKDU1DSV9VTkRFRklORUQQABINCglNQ0lf", 
            "RVJST1IQARIPCgtNQ0lfU1RPUFBFRBACEg8KC01DSV9SVU5OSU5HEAMiyQEK", 
            "F0VnbXJpUmFwaWRDdHJsRXhlY1N0YXRlElkKBXN0YXRlGAEgAigOMjkuYWJi", 
            "LmVnbXJpLkVnbXJpUmFwaWRDdHJsRXhlY1N0YXRlLlJhcGlkQ3RybEV4ZWNT", 
            "dGF0ZVR5cGU6D1JBUElEX1VOREVGSU5FRCJTChZSYXBpZEN0cmxFeGVjU3Rh", 
            "dGVUeXBlEhMKD1JBUElEX1VOREVGSU5FRBAAEhEKDVJBUElEX1NUT1BQRUQQ", 
            "ARIRCg1SQVBJRF9SVU5OSU5HEAIiIwoQRWdtcmlUZXN0U2lnbmFscxIPCgdz", 
            "aWduYWxzGAEgAygCIqUDCgpFZ21yaVJvYm90EiYKBmhlYWRlchgBIAEoCzIW", 
            "LmFiYi5lZ21yaS5FZ21yaUhlYWRlchIqCghmZWVkYmFjaxgCIAEoCzIYLmFi", 
            "Yi5lZ21yaS5FZ21yaUZlZWRiYWNrEigKB3BsYW5uZWQYAyABKAsyFy5hYmIu", 
            "ZWdtcmkuRWdtcmlQbGFubmVkEjQKDXBpZFBhcmFtZXRlcnMYBCABKAsyHS5h", 
            "YmIuZWdtcmkuRWdtcmlQSURQYXJhbWV0ZXJzEi4KCm1vdG9yU3RhdGUYBSAB", 
            "KAsyGi5hYmIuZWdtcmkuRWdtcmlNb3RvclN0YXRlEioKCG1jaVN0YXRlGAYg", 
            "ASgLMhguYWJiLmVnbXJpLkVnbXJpTUNJU3RhdGUSGQoRbWNpQ29udmVyZ2Vu", 
            "Y2VNZXQYByABKAgSMAoLdGVzdFNpZ25hbHMYCCABKAsyGy5hYmIuZWdtcmku", 
            "RWdtcmlUZXN0U2lnbmFscxI6Cg5yYXBpZEV4ZWNTdGF0ZRgJIAEoCzIiLmFi", 
            "Yi5lZ21yaS5FZ21yaVJhcGlkQ3RybEV4ZWNTdGF0ZSKPAgoLRWdtcmlTZW5z", 
            "b3ISJgoGaGVhZGVyGAEgASgLMhYuYWJiLmVnbXJpLkVnbXJpSGVhZGVyEjYK", 
            "EnBvc2l0aW9uUmVmZXJlbmNlcxgCIAEoCzIaLmFiYi5lZ21yaS5FZ21yaUpv", 
            "aW50U3BhY2USMwoPc3BlZWRSZWZlcmVuY2VzGAMgASgLMhouYWJiLmVnbXJp", 
            "LkVnbXJpSm9pbnRTcGFjZRI1ChF0b3JxdWVGZWVkZm9yd2FyZBgEIAEoCzIa", 
            "LmFiYi5lZ21yaS5FZ21yaUpvaW50U3BhY2USNAoNcGlkUGFyYW1ldGVycxgF", 
          "IAEoCzIdLmFiYi5lZ21yaS5FZ21yaVBJRFBhcmFtZXRlcnM="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_abb_egmri_EgmriHeader__Descriptor = Descriptor.MessageTypes[0];
        internal__static_abb_egmri_EgmriHeader__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriHeader, global::abb.egmri.EgmriHeader.Builder>(internal__static_abb_egmri_EgmriHeader__Descriptor,
                new string[] { "Seqno", "Tm", "Mtype", });
        internal__static_abb_egmri_EgmriCartesian__Descriptor = Descriptor.MessageTypes[1];
        internal__static_abb_egmri_EgmriCartesian__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriCartesian, global::abb.egmri.EgmriCartesian.Builder>(internal__static_abb_egmri_EgmriCartesian__Descriptor,
                new string[] { "X", "Y", "Z", });
        internal__static_abb_egmri_EgmriQuaternion__Descriptor = Descriptor.MessageTypes[2];
        internal__static_abb_egmri_EgmriQuaternion__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriQuaternion, global::abb.egmri.EgmriQuaternion.Builder>(internal__static_abb_egmri_EgmriQuaternion__Descriptor,
                new string[] { "U0", "U1", "U2", "U3", });
        internal__static_abb_egmri_EgmriPose__Descriptor = Descriptor.MessageTypes[3];
        internal__static_abb_egmri_EgmriPose__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriPose, global::abb.egmri.EgmriPose.Builder>(internal__static_abb_egmri_EgmriPose__Descriptor,
                new string[] { "Position", "Orientation", });
        internal__static_abb_egmri_EgmriJoints__Descriptor = Descriptor.MessageTypes[4];
        internal__static_abb_egmri_EgmriJoints__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriJoints, global::abb.egmri.EgmriJoints.Builder>(internal__static_abb_egmri_EgmriJoints__Descriptor,
                new string[] { "Joints", });
        internal__static_abb_egmri_EgmriJointSpace__Descriptor = Descriptor.MessageTypes[5];
        internal__static_abb_egmri_EgmriJointSpace__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriJointSpace, global::abb.egmri.EgmriJointSpace.Builder>(internal__static_abb_egmri_EgmriJointSpace__Descriptor,
                new string[] { "Joints", "ExternalJoints", });
        internal__static_abb_egmri_EgmriFeedback__Descriptor = Descriptor.MessageTypes[6];
        internal__static_abb_egmri_EgmriFeedback__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriFeedback, global::abb.egmri.EgmriFeedback.Builder>(internal__static_abb_egmri_EgmriFeedback__Descriptor,
                new string[] { "CartesianPose", "JointPosition", "JointSpeed", "JointTorque", });
        internal__static_abb_egmri_EgmriPlanned__Descriptor = Descriptor.MessageTypes[7];
        internal__static_abb_egmri_EgmriPlanned__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriPlanned, global::abb.egmri.EgmriPlanned.Builder>(internal__static_abb_egmri_EgmriPlanned__Descriptor,
                new string[] { "CartesianPose", "JointPosition", "JointSpeed", });
        internal__static_abb_egmri_EgmriPIDParameters__Descriptor = Descriptor.MessageTypes[8];
        internal__static_abb_egmri_EgmriPIDParameters__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriPIDParameters, global::abb.egmri.EgmriPIDParameters.Builder>(internal__static_abb_egmri_EgmriPIDParameters__Descriptor,
                new string[] { "Kp", "Kv", "Ki", });
        internal__static_abb_egmri_EgmriMotorState__Descriptor = Descriptor.MessageTypes[9];
        internal__static_abb_egmri_EgmriMotorState__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriMotorState, global::abb.egmri.EgmriMotorState.Builder>(internal__static_abb_egmri_EgmriMotorState__Descriptor,
                new string[] { "State", });
        internal__static_abb_egmri_EgmriMCIState__Descriptor = Descriptor.MessageTypes[10];
        internal__static_abb_egmri_EgmriMCIState__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriMCIState, global::abb.egmri.EgmriMCIState.Builder>(internal__static_abb_egmri_EgmriMCIState__Descriptor,
                new string[] { "State", });
        internal__static_abb_egmri_EgmriRapidCtrlExecState__Descriptor = Descriptor.MessageTypes[11];
        internal__static_abb_egmri_EgmriRapidCtrlExecState__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriRapidCtrlExecState, global::abb.egmri.EgmriRapidCtrlExecState.Builder>(internal__static_abb_egmri_EgmriRapidCtrlExecState__Descriptor,
                new string[] { "State", });
        internal__static_abb_egmri_EgmriTestSignals__Descriptor = Descriptor.MessageTypes[12];
        internal__static_abb_egmri_EgmriTestSignals__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriTestSignals, global::abb.egmri.EgmriTestSignals.Builder>(internal__static_abb_egmri_EgmriTestSignals__Descriptor,
                new string[] { "Signals", });
        internal__static_abb_egmri_EgmriRobot__Descriptor = Descriptor.MessageTypes[13];
        internal__static_abb_egmri_EgmriRobot__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriRobot, global::abb.egmri.EgmriRobot.Builder>(internal__static_abb_egmri_EgmriRobot__Descriptor,
                new string[] { "Header", "Feedback", "Planned", "PidParameters", "MotorState", "MciState", "MciConvergenceMet", "TestSignals", "RapidExecState", });
        internal__static_abb_egmri_EgmriSensor__Descriptor = Descriptor.MessageTypes[14];
        internal__static_abb_egmri_EgmriSensor__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::abb.egmri.EgmriSensor, global::abb.egmri.EgmriSensor.Builder>(internal__static_abb_egmri_EgmriSensor__Descriptor,
                new string[] { "Header", "PositionReferences", "SpeedReferences", "TorqueFeedforward", "PidParameters", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriHeader : pb::GeneratedMessage<EgmriHeader, EgmriHeader.Builder> {
    private EgmriHeader() { }
    private static readonly EgmriHeader defaultInstance = new EgmriHeader().MakeReadOnly();
    private static readonly string[] _egmriHeaderFieldNames = new string[] { "mtype", "seqno", "tm" };
    private static readonly uint[] _egmriHeaderFieldTags = new uint[] { 24, 8, 16 };
    public static EgmriHeader DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriHeader DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriHeader ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriHeader__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriHeader, EgmriHeader.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriHeader__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum MessageType {
        MSGTYPE_UNDEFINED = 0,
        MSGTYPE_COMMAND = 1,
        MSGTYPE_DATA = 2,
        MSGTYPE_CORRECTION = 3,
      }
      
    }
    #endregion
    
    public const int SeqnoFieldNumber = 1;
    private bool hasSeqno;
    private uint seqno_;
    public bool HasSeqno {
      get { return hasSeqno; }
    }
    [global::System.CLSCompliant(false)]
    public uint Seqno {
      get { return seqno_; }
    }
    
    public const int TmFieldNumber = 2;
    private bool hasTm;
    private uint tm_;
    public bool HasTm {
      get { return hasTm; }
    }
    [global::System.CLSCompliant(false)]
    public uint Tm {
      get { return tm_; }
    }
    
    public const int MtypeFieldNumber = 3;
    private bool hasMtype;
    private global::abb.egmri.EgmriHeader.Types.MessageType mtype_ = global::abb.egmri.EgmriHeader.Types.MessageType.MSGTYPE_UNDEFINED;
    public bool HasMtype {
      get { return hasMtype; }
    }
    public global::abb.egmri.EgmriHeader.Types.MessageType Mtype {
      get { return mtype_; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriHeaderFieldNames;
      if (hasSeqno) {
        output.WriteUInt32(1, field_names[1], Seqno);
      }
      if (hasTm) {
        output.WriteUInt32(2, field_names[2], Tm);
      }
      if (hasMtype) {
        output.WriteEnum(3, field_names[0], (int) Mtype, Mtype);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSeqno) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Seqno);
      }
      if (hasTm) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, Tm);
      }
      if (hasMtype) {
        size += pb::CodedOutputStream.ComputeEnumSize(3, (int) Mtype);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriHeader ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriHeader ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriHeader ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriHeader ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriHeader ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriHeader ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriHeader ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriHeader ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriHeader ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriHeader ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriHeader MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriHeader prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriHeader, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriHeader cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriHeader result;
      
      private EgmriHeader PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriHeader original = result;
          result = new EgmriHeader();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriHeader MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriHeader.Descriptor; }
      }
      
      public override EgmriHeader DefaultInstanceForType {
        get { return global::abb.egmri.EgmriHeader.DefaultInstance; }
      }
      
      public override EgmriHeader BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriHeader) {
          return MergeFrom((EgmriHeader) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriHeader other) {
        if (other == global::abb.egmri.EgmriHeader.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSeqno) {
          Seqno = other.Seqno;
        }
        if (other.HasTm) {
          Tm = other.Tm;
        }
        if (other.HasMtype) {
          Mtype = other.Mtype;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriHeaderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriHeaderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasSeqno = input.ReadUInt32(ref result.seqno_);
              break;
            }
            case 16: {
              result.hasTm = input.ReadUInt32(ref result.tm_);
              break;
            }
            case 24: {
              object unknown;
              if(input.ReadEnum(ref result.mtype_, out unknown)) {
                result.hasMtype = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(3, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasSeqno {
        get { return result.hasSeqno; }
      }
      [global::System.CLSCompliant(false)]
      public uint Seqno {
        get { return result.Seqno; }
        set { SetSeqno(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetSeqno(uint value) {
        PrepareBuilder();
        result.hasSeqno = true;
        result.seqno_ = value;
        return this;
      }
      public Builder ClearSeqno() {
        PrepareBuilder();
        result.hasSeqno = false;
        result.seqno_ = 0;
        return this;
      }
      
      public bool HasTm {
        get { return result.hasTm; }
      }
      [global::System.CLSCompliant(false)]
      public uint Tm {
        get { return result.Tm; }
        set { SetTm(value); }
      }
      [global::System.CLSCompliant(false)]
      public Builder SetTm(uint value) {
        PrepareBuilder();
        result.hasTm = true;
        result.tm_ = value;
        return this;
      }
      public Builder ClearTm() {
        PrepareBuilder();
        result.hasTm = false;
        result.tm_ = 0;
        return this;
      }
      
      public bool HasMtype {
       get { return result.hasMtype; }
      }
      public global::abb.egmri.EgmriHeader.Types.MessageType Mtype {
        get { return result.Mtype; }
        set { SetMtype(value); }
      }
      public Builder SetMtype(global::abb.egmri.EgmriHeader.Types.MessageType value) {
        PrepareBuilder();
        result.hasMtype = true;
        result.mtype_ = value;
        return this;
      }
      public Builder ClearMtype() {
        PrepareBuilder();
        result.hasMtype = false;
        result.mtype_ = global::abb.egmri.EgmriHeader.Types.MessageType.MSGTYPE_UNDEFINED;
        return this;
      }
    }
    static EgmriHeader() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriCartesian : pb::GeneratedMessage<EgmriCartesian, EgmriCartesian.Builder> {
    private EgmriCartesian() { }
    private static readonly EgmriCartesian defaultInstance = new EgmriCartesian().MakeReadOnly();
    private static readonly string[] _egmriCartesianFieldNames = new string[] { "x", "y", "z" };
    private static readonly uint[] _egmriCartesianFieldTags = new uint[] { 13, 21, 29 };
    public static EgmriCartesian DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriCartesian DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriCartesian ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriCartesian__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriCartesian, EgmriCartesian.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriCartesian__FieldAccessorTable; }
    }
    
    public const int XFieldNumber = 1;
    private bool hasX;
    private float x_;
    public bool HasX {
      get { return hasX; }
    }
    public float X {
      get { return x_; }
    }
    
    public const int YFieldNumber = 2;
    private bool hasY;
    private float y_;
    public bool HasY {
      get { return hasY; }
    }
    public float Y {
      get { return y_; }
    }
    
    public const int ZFieldNumber = 3;
    private bool hasZ;
    private float z_;
    public bool HasZ {
      get { return hasZ; }
    }
    public float Z {
      get { return z_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasX) return false;
        if (!hasY) return false;
        if (!hasZ) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriCartesianFieldNames;
      if (hasX) {
        output.WriteFloat(1, field_names[0], X);
      }
      if (hasY) {
        output.WriteFloat(2, field_names[1], Y);
      }
      if (hasZ) {
        output.WriteFloat(3, field_names[2], Z);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasX) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, X);
      }
      if (hasY) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
      }
      if (hasZ) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriCartesian ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriCartesian ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriCartesian ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriCartesian ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriCartesian MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriCartesian prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriCartesian, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriCartesian cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriCartesian result;
      
      private EgmriCartesian PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriCartesian original = result;
          result = new EgmriCartesian();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriCartesian MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriCartesian.Descriptor; }
      }
      
      public override EgmriCartesian DefaultInstanceForType {
        get { return global::abb.egmri.EgmriCartesian.DefaultInstance; }
      }
      
      public override EgmriCartesian BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriCartesian) {
          return MergeFrom((EgmriCartesian) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriCartesian other) {
        if (other == global::abb.egmri.EgmriCartesian.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasX) {
          X = other.X;
        }
        if (other.HasY) {
          Y = other.Y;
        }
        if (other.HasZ) {
          Z = other.Z;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriCartesianFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriCartesianFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasX = input.ReadFloat(ref result.x_);
              break;
            }
            case 21: {
              result.hasY = input.ReadFloat(ref result.y_);
              break;
            }
            case 29: {
              result.hasZ = input.ReadFloat(ref result.z_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasX {
        get { return result.hasX; }
      }
      public float X {
        get { return result.X; }
        set { SetX(value); }
      }
      public Builder SetX(float value) {
        PrepareBuilder();
        result.hasX = true;
        result.x_ = value;
        return this;
      }
      public Builder ClearX() {
        PrepareBuilder();
        result.hasX = false;
        result.x_ = 0F;
        return this;
      }
      
      public bool HasY {
        get { return result.hasY; }
      }
      public float Y {
        get { return result.Y; }
        set { SetY(value); }
      }
      public Builder SetY(float value) {
        PrepareBuilder();
        result.hasY = true;
        result.y_ = value;
        return this;
      }
      public Builder ClearY() {
        PrepareBuilder();
        result.hasY = false;
        result.y_ = 0F;
        return this;
      }
      
      public bool HasZ {
        get { return result.hasZ; }
      }
      public float Z {
        get { return result.Z; }
        set { SetZ(value); }
      }
      public Builder SetZ(float value) {
        PrepareBuilder();
        result.hasZ = true;
        result.z_ = value;
        return this;
      }
      public Builder ClearZ() {
        PrepareBuilder();
        result.hasZ = false;
        result.z_ = 0F;
        return this;
      }
    }
    static EgmriCartesian() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriQuaternion : pb::GeneratedMessage<EgmriQuaternion, EgmriQuaternion.Builder> {
    private EgmriQuaternion() { }
    private static readonly EgmriQuaternion defaultInstance = new EgmriQuaternion().MakeReadOnly();
    private static readonly string[] _egmriQuaternionFieldNames = new string[] { "u0", "u1", "u2", "u3" };
    private static readonly uint[] _egmriQuaternionFieldTags = new uint[] { 13, 21, 29, 37 };
    public static EgmriQuaternion DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriQuaternion DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriQuaternion ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriQuaternion__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriQuaternion, EgmriQuaternion.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriQuaternion__FieldAccessorTable; }
    }
    
    public const int U0FieldNumber = 1;
    private bool hasU0;
    private float u0_;
    public bool HasU0 {
      get { return hasU0; }
    }
    public float U0 {
      get { return u0_; }
    }
    
    public const int U1FieldNumber = 2;
    private bool hasU1;
    private float u1_;
    public bool HasU1 {
      get { return hasU1; }
    }
    public float U1 {
      get { return u1_; }
    }
    
    public const int U2FieldNumber = 3;
    private bool hasU2;
    private float u2_;
    public bool HasU2 {
      get { return hasU2; }
    }
    public float U2 {
      get { return u2_; }
    }
    
    public const int U3FieldNumber = 4;
    private bool hasU3;
    private float u3_;
    public bool HasU3 {
      get { return hasU3; }
    }
    public float U3 {
      get { return u3_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasU0) return false;
        if (!hasU1) return false;
        if (!hasU2) return false;
        if (!hasU3) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriQuaternionFieldNames;
      if (hasU0) {
        output.WriteFloat(1, field_names[0], U0);
      }
      if (hasU1) {
        output.WriteFloat(2, field_names[1], U1);
      }
      if (hasU2) {
        output.WriteFloat(3, field_names[2], U2);
      }
      if (hasU3) {
        output.WriteFloat(4, field_names[3], U3);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasU0) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, U0);
      }
      if (hasU1) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, U1);
      }
      if (hasU2) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, U2);
      }
      if (hasU3) {
        size += pb::CodedOutputStream.ComputeFloatSize(4, U3);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriQuaternion ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriQuaternion ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriQuaternion ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriQuaternion ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriQuaternion MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriQuaternion prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriQuaternion, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriQuaternion cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriQuaternion result;
      
      private EgmriQuaternion PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriQuaternion original = result;
          result = new EgmriQuaternion();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriQuaternion MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriQuaternion.Descriptor; }
      }
      
      public override EgmriQuaternion DefaultInstanceForType {
        get { return global::abb.egmri.EgmriQuaternion.DefaultInstance; }
      }
      
      public override EgmriQuaternion BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriQuaternion) {
          return MergeFrom((EgmriQuaternion) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriQuaternion other) {
        if (other == global::abb.egmri.EgmriQuaternion.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasU0) {
          U0 = other.U0;
        }
        if (other.HasU1) {
          U1 = other.U1;
        }
        if (other.HasU2) {
          U2 = other.U2;
        }
        if (other.HasU3) {
          U3 = other.U3;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriQuaternionFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriQuaternionFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 13: {
              result.hasU0 = input.ReadFloat(ref result.u0_);
              break;
            }
            case 21: {
              result.hasU1 = input.ReadFloat(ref result.u1_);
              break;
            }
            case 29: {
              result.hasU2 = input.ReadFloat(ref result.u2_);
              break;
            }
            case 37: {
              result.hasU3 = input.ReadFloat(ref result.u3_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasU0 {
        get { return result.hasU0; }
      }
      public float U0 {
        get { return result.U0; }
        set { SetU0(value); }
      }
      public Builder SetU0(float value) {
        PrepareBuilder();
        result.hasU0 = true;
        result.u0_ = value;
        return this;
      }
      public Builder ClearU0() {
        PrepareBuilder();
        result.hasU0 = false;
        result.u0_ = 0F;
        return this;
      }
      
      public bool HasU1 {
        get { return result.hasU1; }
      }
      public float U1 {
        get { return result.U1; }
        set { SetU1(value); }
      }
      public Builder SetU1(float value) {
        PrepareBuilder();
        result.hasU1 = true;
        result.u1_ = value;
        return this;
      }
      public Builder ClearU1() {
        PrepareBuilder();
        result.hasU1 = false;
        result.u1_ = 0F;
        return this;
      }
      
      public bool HasU2 {
        get { return result.hasU2; }
      }
      public float U2 {
        get { return result.U2; }
        set { SetU2(value); }
      }
      public Builder SetU2(float value) {
        PrepareBuilder();
        result.hasU2 = true;
        result.u2_ = value;
        return this;
      }
      public Builder ClearU2() {
        PrepareBuilder();
        result.hasU2 = false;
        result.u2_ = 0F;
        return this;
      }
      
      public bool HasU3 {
        get { return result.hasU3; }
      }
      public float U3 {
        get { return result.U3; }
        set { SetU3(value); }
      }
      public Builder SetU3(float value) {
        PrepareBuilder();
        result.hasU3 = true;
        result.u3_ = value;
        return this;
      }
      public Builder ClearU3() {
        PrepareBuilder();
        result.hasU3 = false;
        result.u3_ = 0F;
        return this;
      }
    }
    static EgmriQuaternion() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriPose : pb::GeneratedMessage<EgmriPose, EgmriPose.Builder> {
    private EgmriPose() { }
    private static readonly EgmriPose defaultInstance = new EgmriPose().MakeReadOnly();
    private static readonly string[] _egmriPoseFieldNames = new string[] { "orientation", "position" };
    private static readonly uint[] _egmriPoseFieldTags = new uint[] { 18, 10 };
    public static EgmriPose DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriPose DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriPose ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriPose__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriPose, EgmriPose.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriPose__FieldAccessorTable; }
    }
    
    public const int PositionFieldNumber = 1;
    private bool hasPosition;
    private global::abb.egmri.EgmriCartesian position_;
    public bool HasPosition {
      get { return hasPosition; }
    }
    public global::abb.egmri.EgmriCartesian Position {
      get { return position_ ?? global::abb.egmri.EgmriCartesian.DefaultInstance; }
    }
    
    public const int OrientationFieldNumber = 2;
    private bool hasOrientation;
    private global::abb.egmri.EgmriQuaternion orientation_;
    public bool HasOrientation {
      get { return hasOrientation; }
    }
    public global::abb.egmri.EgmriQuaternion Orientation {
      get { return orientation_ ?? global::abb.egmri.EgmriQuaternion.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasPosition) {
          if (!Position.IsInitialized) return false;
        }
        if (HasOrientation) {
          if (!Orientation.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriPoseFieldNames;
      if (hasPosition) {
        output.WriteMessage(1, field_names[1], Position);
      }
      if (hasOrientation) {
        output.WriteMessage(2, field_names[0], Orientation);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Position);
      }
      if (hasOrientation) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Orientation);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriPose ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriPose ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriPose ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriPose ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriPose ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriPose ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriPose ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriPose ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriPose ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriPose ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriPose MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriPose prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriPose, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriPose cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriPose result;
      
      private EgmriPose PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriPose original = result;
          result = new EgmriPose();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriPose MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriPose.Descriptor; }
      }
      
      public override EgmriPose DefaultInstanceForType {
        get { return global::abb.egmri.EgmriPose.DefaultInstance; }
      }
      
      public override EgmriPose BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriPose) {
          return MergeFrom((EgmriPose) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriPose other) {
        if (other == global::abb.egmri.EgmriPose.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasPosition) {
          MergePosition(other.Position);
        }
        if (other.HasOrientation) {
          MergeOrientation(other.Orientation);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriPoseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriPoseFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriCartesian.Builder subBuilder = global::abb.egmri.EgmriCartesian.CreateBuilder();
              if (result.hasPosition) {
                subBuilder.MergeFrom(Position);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Position = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriQuaternion.Builder subBuilder = global::abb.egmri.EgmriQuaternion.CreateBuilder();
              if (result.hasOrientation) {
                subBuilder.MergeFrom(Orientation);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Orientation = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasPosition {
       get { return result.hasPosition; }
      }
      public global::abb.egmri.EgmriCartesian Position {
        get { return result.Position; }
        set { SetPosition(value); }
      }
      public Builder SetPosition(global::abb.egmri.EgmriCartesian value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = value;
        return this;
      }
      public Builder SetPosition(global::abb.egmri.EgmriCartesian.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPosition = true;
        result.position_ = builderForValue.Build();
        return this;
      }
      public Builder MergePosition(global::abb.egmri.EgmriCartesian value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPosition &&
            result.position_ != global::abb.egmri.EgmriCartesian.DefaultInstance) {
            result.position_ = global::abb.egmri.EgmriCartesian.CreateBuilder(result.position_).MergeFrom(value).BuildPartial();
        } else {
          result.position_ = value;
        }
        result.hasPosition = true;
        return this;
      }
      public Builder ClearPosition() {
        PrepareBuilder();
        result.hasPosition = false;
        result.position_ = null;
        return this;
      }
      
      public bool HasOrientation {
       get { return result.hasOrientation; }
      }
      public global::abb.egmri.EgmriQuaternion Orientation {
        get { return result.Orientation; }
        set { SetOrientation(value); }
      }
      public Builder SetOrientation(global::abb.egmri.EgmriQuaternion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOrientation = true;
        result.orientation_ = value;
        return this;
      }
      public Builder SetOrientation(global::abb.egmri.EgmriQuaternion.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOrientation = true;
        result.orientation_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOrientation(global::abb.egmri.EgmriQuaternion value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOrientation &&
            result.orientation_ != global::abb.egmri.EgmriQuaternion.DefaultInstance) {
            result.orientation_ = global::abb.egmri.EgmriQuaternion.CreateBuilder(result.orientation_).MergeFrom(value).BuildPartial();
        } else {
          result.orientation_ = value;
        }
        result.hasOrientation = true;
        return this;
      }
      public Builder ClearOrientation() {
        PrepareBuilder();
        result.hasOrientation = false;
        result.orientation_ = null;
        return this;
      }
    }
    static EgmriPose() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriJoints : pb::GeneratedMessage<EgmriJoints, EgmriJoints.Builder> {
    private EgmriJoints() { }
    private static readonly EgmriJoints defaultInstance = new EgmriJoints().MakeReadOnly();
    private static readonly string[] _egmriJointsFieldNames = new string[] { "joints" };
    private static readonly uint[] _egmriJointsFieldTags = new uint[] { 13 };
    public static EgmriJoints DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriJoints DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriJoints ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriJoints__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriJoints, EgmriJoints.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriJoints__FieldAccessorTable; }
    }
    
    public const int JointsFieldNumber = 1;
    private pbc::PopsicleList<float> joints_ = new pbc::PopsicleList<float>();
    public scg::IList<float> JointsList {
      get { return pbc::Lists.AsReadOnly(joints_); }
    }
    public int JointsCount {
      get { return joints_.Count; }
    }
    public float GetJoints(int index) {
      return joints_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriJointsFieldNames;
      if (joints_.Count > 0) {
        output.WriteFloatArray(1, field_names[0], joints_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      {
        int dataSize = 0;
        dataSize = 4 * joints_.Count;
        size += dataSize;
        size += 1 * joints_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriJoints ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriJoints ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriJoints ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriJoints ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriJoints ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriJoints ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriJoints ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriJoints ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriJoints ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriJoints ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriJoints MakeReadOnly() {
      joints_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriJoints prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriJoints, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriJoints cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriJoints result;
      
      private EgmriJoints PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriJoints original = result;
          result = new EgmriJoints();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriJoints MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriJoints.Descriptor; }
      }
      
      public override EgmriJoints DefaultInstanceForType {
        get { return global::abb.egmri.EgmriJoints.DefaultInstance; }
      }
      
      public override EgmriJoints BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriJoints) {
          return MergeFrom((EgmriJoints) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriJoints other) {
        if (other == global::abb.egmri.EgmriJoints.DefaultInstance) return this;
        PrepareBuilder();
        if (other.joints_.Count != 0) {
          result.joints_.Add(other.joints_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriJointsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriJointsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10:
            case 13: {
              input.ReadFloatArray(tag, field_name, result.joints_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<float> JointsList {
        get { return PrepareBuilder().joints_; }
      }
      public int JointsCount {
        get { return result.JointsCount; }
      }
      public float GetJoints(int index) {
        return result.GetJoints(index);
      }
      public Builder SetJoints(int index, float value) {
        PrepareBuilder();
        result.joints_[index] = value;
        return this;
      }
      public Builder AddJoints(float value) {
        PrepareBuilder();
        result.joints_.Add(value);
        return this;
      }
      public Builder AddRangeJoints(scg::IEnumerable<float> values) {
        PrepareBuilder();
        result.joints_.Add(values);
        return this;
      }
      public Builder ClearJoints() {
        PrepareBuilder();
        result.joints_.Clear();
        return this;
      }
    }
    static EgmriJoints() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriJointSpace : pb::GeneratedMessage<EgmriJointSpace, EgmriJointSpace.Builder> {
    private EgmriJointSpace() { }
    private static readonly EgmriJointSpace defaultInstance = new EgmriJointSpace().MakeReadOnly();
    private static readonly string[] _egmriJointSpaceFieldNames = new string[] { "externalJoints", "joints" };
    private static readonly uint[] _egmriJointSpaceFieldTags = new uint[] { 18, 10 };
    public static EgmriJointSpace DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriJointSpace DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriJointSpace ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriJointSpace__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriJointSpace, EgmriJointSpace.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriJointSpace__FieldAccessorTable; }
    }
    
    public const int JointsFieldNumber = 1;
    private bool hasJoints;
    private global::abb.egmri.EgmriJoints joints_;
    public bool HasJoints {
      get { return hasJoints; }
    }
    public global::abb.egmri.EgmriJoints Joints {
      get { return joints_ ?? global::abb.egmri.EgmriJoints.DefaultInstance; }
    }
    
    public const int ExternalJointsFieldNumber = 2;
    private bool hasExternalJoints;
    private global::abb.egmri.EgmriJoints externalJoints_;
    public bool HasExternalJoints {
      get { return hasExternalJoints; }
    }
    public global::abb.egmri.EgmriJoints ExternalJoints {
      get { return externalJoints_ ?? global::abb.egmri.EgmriJoints.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriJointSpaceFieldNames;
      if (hasJoints) {
        output.WriteMessage(1, field_names[1], Joints);
      }
      if (hasExternalJoints) {
        output.WriteMessage(2, field_names[0], ExternalJoints);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasJoints) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Joints);
      }
      if (hasExternalJoints) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, ExternalJoints);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriJointSpace ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriJointSpace ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriJointSpace ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriJointSpace ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriJointSpace MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriJointSpace prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriJointSpace, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriJointSpace cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriJointSpace result;
      
      private EgmriJointSpace PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriJointSpace original = result;
          result = new EgmriJointSpace();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriJointSpace MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriJointSpace.Descriptor; }
      }
      
      public override EgmriJointSpace DefaultInstanceForType {
        get { return global::abb.egmri.EgmriJointSpace.DefaultInstance; }
      }
      
      public override EgmriJointSpace BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriJointSpace) {
          return MergeFrom((EgmriJointSpace) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriJointSpace other) {
        if (other == global::abb.egmri.EgmriJointSpace.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasJoints) {
          MergeJoints(other.Joints);
        }
        if (other.HasExternalJoints) {
          MergeExternalJoints(other.ExternalJoints);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriJointSpaceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriJointSpaceFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriJoints.Builder subBuilder = global::abb.egmri.EgmriJoints.CreateBuilder();
              if (result.hasJoints) {
                subBuilder.MergeFrom(Joints);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Joints = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriJoints.Builder subBuilder = global::abb.egmri.EgmriJoints.CreateBuilder();
              if (result.hasExternalJoints) {
                subBuilder.MergeFrom(ExternalJoints);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              ExternalJoints = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasJoints {
       get { return result.hasJoints; }
      }
      public global::abb.egmri.EgmriJoints Joints {
        get { return result.Joints; }
        set { SetJoints(value); }
      }
      public Builder SetJoints(global::abb.egmri.EgmriJoints value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJoints = true;
        result.joints_ = value;
        return this;
      }
      public Builder SetJoints(global::abb.egmri.EgmriJoints.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJoints = true;
        result.joints_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJoints(global::abb.egmri.EgmriJoints value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJoints &&
            result.joints_ != global::abb.egmri.EgmriJoints.DefaultInstance) {
            result.joints_ = global::abb.egmri.EgmriJoints.CreateBuilder(result.joints_).MergeFrom(value).BuildPartial();
        } else {
          result.joints_ = value;
        }
        result.hasJoints = true;
        return this;
      }
      public Builder ClearJoints() {
        PrepareBuilder();
        result.hasJoints = false;
        result.joints_ = null;
        return this;
      }
      
      public bool HasExternalJoints {
       get { return result.hasExternalJoints; }
      }
      public global::abb.egmri.EgmriJoints ExternalJoints {
        get { return result.ExternalJoints; }
        set { SetExternalJoints(value); }
      }
      public Builder SetExternalJoints(global::abb.egmri.EgmriJoints value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExternalJoints = true;
        result.externalJoints_ = value;
        return this;
      }
      public Builder SetExternalJoints(global::abb.egmri.EgmriJoints.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasExternalJoints = true;
        result.externalJoints_ = builderForValue.Build();
        return this;
      }
      public Builder MergeExternalJoints(global::abb.egmri.EgmriJoints value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasExternalJoints &&
            result.externalJoints_ != global::abb.egmri.EgmriJoints.DefaultInstance) {
            result.externalJoints_ = global::abb.egmri.EgmriJoints.CreateBuilder(result.externalJoints_).MergeFrom(value).BuildPartial();
        } else {
          result.externalJoints_ = value;
        }
        result.hasExternalJoints = true;
        return this;
      }
      public Builder ClearExternalJoints() {
        PrepareBuilder();
        result.hasExternalJoints = false;
        result.externalJoints_ = null;
        return this;
      }
    }
    static EgmriJointSpace() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriFeedback : pb::GeneratedMessage<EgmriFeedback, EgmriFeedback.Builder> {
    private EgmriFeedback() { }
    private static readonly EgmriFeedback defaultInstance = new EgmriFeedback().MakeReadOnly();
    private static readonly string[] _egmriFeedbackFieldNames = new string[] { "cartesianPose", "jointPosition", "jointSpeed", "jointTorque" };
    private static readonly uint[] _egmriFeedbackFieldTags = new uint[] { 10, 18, 26, 34 };
    public static EgmriFeedback DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriFeedback DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriFeedback ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriFeedback__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriFeedback, EgmriFeedback.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriFeedback__FieldAccessorTable; }
    }
    
    public const int CartesianPoseFieldNumber = 1;
    private bool hasCartesianPose;
    private global::abb.egmri.EgmriPose cartesianPose_;
    public bool HasCartesianPose {
      get { return hasCartesianPose; }
    }
    public global::abb.egmri.EgmriPose CartesianPose {
      get { return cartesianPose_ ?? global::abb.egmri.EgmriPose.DefaultInstance; }
    }
    
    public const int JointPositionFieldNumber = 2;
    private bool hasJointPosition;
    private global::abb.egmri.EgmriJointSpace jointPosition_;
    public bool HasJointPosition {
      get { return hasJointPosition; }
    }
    public global::abb.egmri.EgmriJointSpace JointPosition {
      get { return jointPosition_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int JointSpeedFieldNumber = 3;
    private bool hasJointSpeed;
    private global::abb.egmri.EgmriJointSpace jointSpeed_;
    public bool HasJointSpeed {
      get { return hasJointSpeed; }
    }
    public global::abb.egmri.EgmriJointSpace JointSpeed {
      get { return jointSpeed_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int JointTorqueFieldNumber = 4;
    private bool hasJointTorque;
    private global::abb.egmri.EgmriJointSpace jointTorque_;
    public bool HasJointTorque {
      get { return hasJointTorque; }
    }
    public global::abb.egmri.EgmriJointSpace JointTorque {
      get { return jointTorque_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasCartesianPose) {
          if (!CartesianPose.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriFeedbackFieldNames;
      if (hasCartesianPose) {
        output.WriteMessage(1, field_names[0], CartesianPose);
      }
      if (hasJointPosition) {
        output.WriteMessage(2, field_names[1], JointPosition);
      }
      if (hasJointSpeed) {
        output.WriteMessage(3, field_names[2], JointSpeed);
      }
      if (hasJointTorque) {
        output.WriteMessage(4, field_names[3], JointTorque);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCartesianPose) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, CartesianPose);
      }
      if (hasJointPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, JointPosition);
      }
      if (hasJointSpeed) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, JointSpeed);
      }
      if (hasJointTorque) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, JointTorque);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriFeedback ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriFeedback ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriFeedback ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriFeedback ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriFeedback MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriFeedback prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriFeedback, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriFeedback cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriFeedback result;
      
      private EgmriFeedback PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriFeedback original = result;
          result = new EgmriFeedback();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriFeedback MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriFeedback.Descriptor; }
      }
      
      public override EgmriFeedback DefaultInstanceForType {
        get { return global::abb.egmri.EgmriFeedback.DefaultInstance; }
      }
      
      public override EgmriFeedback BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriFeedback) {
          return MergeFrom((EgmriFeedback) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriFeedback other) {
        if (other == global::abb.egmri.EgmriFeedback.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCartesianPose) {
          MergeCartesianPose(other.CartesianPose);
        }
        if (other.HasJointPosition) {
          MergeJointPosition(other.JointPosition);
        }
        if (other.HasJointSpeed) {
          MergeJointSpeed(other.JointSpeed);
        }
        if (other.HasJointTorque) {
          MergeJointTorque(other.JointTorque);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriFeedbackFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriFeedbackFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriPose.Builder subBuilder = global::abb.egmri.EgmriPose.CreateBuilder();
              if (result.hasCartesianPose) {
                subBuilder.MergeFrom(CartesianPose);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              CartesianPose = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasJointPosition) {
                subBuilder.MergeFrom(JointPosition);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JointPosition = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasJointSpeed) {
                subBuilder.MergeFrom(JointSpeed);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JointSpeed = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasJointTorque) {
                subBuilder.MergeFrom(JointTorque);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JointTorque = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCartesianPose {
       get { return result.hasCartesianPose; }
      }
      public global::abb.egmri.EgmriPose CartesianPose {
        get { return result.CartesianPose; }
        set { SetCartesianPose(value); }
      }
      public Builder SetCartesianPose(global::abb.egmri.EgmriPose value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCartesianPose = true;
        result.cartesianPose_ = value;
        return this;
      }
      public Builder SetCartesianPose(global::abb.egmri.EgmriPose.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCartesianPose = true;
        result.cartesianPose_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCartesianPose(global::abb.egmri.EgmriPose value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCartesianPose &&
            result.cartesianPose_ != global::abb.egmri.EgmriPose.DefaultInstance) {
            result.cartesianPose_ = global::abb.egmri.EgmriPose.CreateBuilder(result.cartesianPose_).MergeFrom(value).BuildPartial();
        } else {
          result.cartesianPose_ = value;
        }
        result.hasCartesianPose = true;
        return this;
      }
      public Builder ClearCartesianPose() {
        PrepareBuilder();
        result.hasCartesianPose = false;
        result.cartesianPose_ = null;
        return this;
      }
      
      public bool HasJointPosition {
       get { return result.hasJointPosition; }
      }
      public global::abb.egmri.EgmriJointSpace JointPosition {
        get { return result.JointPosition; }
        set { SetJointPosition(value); }
      }
      public Builder SetJointPosition(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJointPosition = true;
        result.jointPosition_ = value;
        return this;
      }
      public Builder SetJointPosition(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJointPosition = true;
        result.jointPosition_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJointPosition(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJointPosition &&
            result.jointPosition_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.jointPosition_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.jointPosition_).MergeFrom(value).BuildPartial();
        } else {
          result.jointPosition_ = value;
        }
        result.hasJointPosition = true;
        return this;
      }
      public Builder ClearJointPosition() {
        PrepareBuilder();
        result.hasJointPosition = false;
        result.jointPosition_ = null;
        return this;
      }
      
      public bool HasJointSpeed {
       get { return result.hasJointSpeed; }
      }
      public global::abb.egmri.EgmriJointSpace JointSpeed {
        get { return result.JointSpeed; }
        set { SetJointSpeed(value); }
      }
      public Builder SetJointSpeed(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJointSpeed = true;
        result.jointSpeed_ = value;
        return this;
      }
      public Builder SetJointSpeed(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJointSpeed = true;
        result.jointSpeed_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJointSpeed(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJointSpeed &&
            result.jointSpeed_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.jointSpeed_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.jointSpeed_).MergeFrom(value).BuildPartial();
        } else {
          result.jointSpeed_ = value;
        }
        result.hasJointSpeed = true;
        return this;
      }
      public Builder ClearJointSpeed() {
        PrepareBuilder();
        result.hasJointSpeed = false;
        result.jointSpeed_ = null;
        return this;
      }
      
      public bool HasJointTorque {
       get { return result.hasJointTorque; }
      }
      public global::abb.egmri.EgmriJointSpace JointTorque {
        get { return result.JointTorque; }
        set { SetJointTorque(value); }
      }
      public Builder SetJointTorque(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJointTorque = true;
        result.jointTorque_ = value;
        return this;
      }
      public Builder SetJointTorque(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJointTorque = true;
        result.jointTorque_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJointTorque(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJointTorque &&
            result.jointTorque_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.jointTorque_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.jointTorque_).MergeFrom(value).BuildPartial();
        } else {
          result.jointTorque_ = value;
        }
        result.hasJointTorque = true;
        return this;
      }
      public Builder ClearJointTorque() {
        PrepareBuilder();
        result.hasJointTorque = false;
        result.jointTorque_ = null;
        return this;
      }
    }
    static EgmriFeedback() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriPlanned : pb::GeneratedMessage<EgmriPlanned, EgmriPlanned.Builder> {
    private EgmriPlanned() { }
    private static readonly EgmriPlanned defaultInstance = new EgmriPlanned().MakeReadOnly();
    private static readonly string[] _egmriPlannedFieldNames = new string[] { "cartesianPose", "jointPosition", "jointSpeed" };
    private static readonly uint[] _egmriPlannedFieldTags = new uint[] { 10, 18, 26 };
    public static EgmriPlanned DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriPlanned DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriPlanned ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriPlanned__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriPlanned, EgmriPlanned.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriPlanned__FieldAccessorTable; }
    }
    
    public const int CartesianPoseFieldNumber = 1;
    private bool hasCartesianPose;
    private global::abb.egmri.EgmriPose cartesianPose_;
    public bool HasCartesianPose {
      get { return hasCartesianPose; }
    }
    public global::abb.egmri.EgmriPose CartesianPose {
      get { return cartesianPose_ ?? global::abb.egmri.EgmriPose.DefaultInstance; }
    }
    
    public const int JointPositionFieldNumber = 2;
    private bool hasJointPosition;
    private global::abb.egmri.EgmriJointSpace jointPosition_;
    public bool HasJointPosition {
      get { return hasJointPosition; }
    }
    public global::abb.egmri.EgmriJointSpace JointPosition {
      get { return jointPosition_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int JointSpeedFieldNumber = 3;
    private bool hasJointSpeed;
    private global::abb.egmri.EgmriJointSpace jointSpeed_;
    public bool HasJointSpeed {
      get { return hasJointSpeed; }
    }
    public global::abb.egmri.EgmriJointSpace JointSpeed {
      get { return jointSpeed_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasCartesianPose) {
          if (!CartesianPose.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriPlannedFieldNames;
      if (hasCartesianPose) {
        output.WriteMessage(1, field_names[0], CartesianPose);
      }
      if (hasJointPosition) {
        output.WriteMessage(2, field_names[1], JointPosition);
      }
      if (hasJointSpeed) {
        output.WriteMessage(3, field_names[2], JointSpeed);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCartesianPose) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, CartesianPose);
      }
      if (hasJointPosition) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, JointPosition);
      }
      if (hasJointSpeed) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, JointSpeed);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriPlanned ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriPlanned ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriPlanned ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriPlanned ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriPlanned MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriPlanned prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriPlanned, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriPlanned cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriPlanned result;
      
      private EgmriPlanned PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriPlanned original = result;
          result = new EgmriPlanned();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriPlanned MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriPlanned.Descriptor; }
      }
      
      public override EgmriPlanned DefaultInstanceForType {
        get { return global::abb.egmri.EgmriPlanned.DefaultInstance; }
      }
      
      public override EgmriPlanned BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriPlanned) {
          return MergeFrom((EgmriPlanned) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriPlanned other) {
        if (other == global::abb.egmri.EgmriPlanned.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasCartesianPose) {
          MergeCartesianPose(other.CartesianPose);
        }
        if (other.HasJointPosition) {
          MergeJointPosition(other.JointPosition);
        }
        if (other.HasJointSpeed) {
          MergeJointSpeed(other.JointSpeed);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriPlannedFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriPlannedFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriPose.Builder subBuilder = global::abb.egmri.EgmriPose.CreateBuilder();
              if (result.hasCartesianPose) {
                subBuilder.MergeFrom(CartesianPose);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              CartesianPose = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasJointPosition) {
                subBuilder.MergeFrom(JointPosition);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JointPosition = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasJointSpeed) {
                subBuilder.MergeFrom(JointSpeed);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              JointSpeed = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasCartesianPose {
       get { return result.hasCartesianPose; }
      }
      public global::abb.egmri.EgmriPose CartesianPose {
        get { return result.CartesianPose; }
        set { SetCartesianPose(value); }
      }
      public Builder SetCartesianPose(global::abb.egmri.EgmriPose value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCartesianPose = true;
        result.cartesianPose_ = value;
        return this;
      }
      public Builder SetCartesianPose(global::abb.egmri.EgmriPose.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasCartesianPose = true;
        result.cartesianPose_ = builderForValue.Build();
        return this;
      }
      public Builder MergeCartesianPose(global::abb.egmri.EgmriPose value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasCartesianPose &&
            result.cartesianPose_ != global::abb.egmri.EgmriPose.DefaultInstance) {
            result.cartesianPose_ = global::abb.egmri.EgmriPose.CreateBuilder(result.cartesianPose_).MergeFrom(value).BuildPartial();
        } else {
          result.cartesianPose_ = value;
        }
        result.hasCartesianPose = true;
        return this;
      }
      public Builder ClearCartesianPose() {
        PrepareBuilder();
        result.hasCartesianPose = false;
        result.cartesianPose_ = null;
        return this;
      }
      
      public bool HasJointPosition {
       get { return result.hasJointPosition; }
      }
      public global::abb.egmri.EgmriJointSpace JointPosition {
        get { return result.JointPosition; }
        set { SetJointPosition(value); }
      }
      public Builder SetJointPosition(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJointPosition = true;
        result.jointPosition_ = value;
        return this;
      }
      public Builder SetJointPosition(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJointPosition = true;
        result.jointPosition_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJointPosition(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJointPosition &&
            result.jointPosition_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.jointPosition_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.jointPosition_).MergeFrom(value).BuildPartial();
        } else {
          result.jointPosition_ = value;
        }
        result.hasJointPosition = true;
        return this;
      }
      public Builder ClearJointPosition() {
        PrepareBuilder();
        result.hasJointPosition = false;
        result.jointPosition_ = null;
        return this;
      }
      
      public bool HasJointSpeed {
       get { return result.hasJointSpeed; }
      }
      public global::abb.egmri.EgmriJointSpace JointSpeed {
        get { return result.JointSpeed; }
        set { SetJointSpeed(value); }
      }
      public Builder SetJointSpeed(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasJointSpeed = true;
        result.jointSpeed_ = value;
        return this;
      }
      public Builder SetJointSpeed(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasJointSpeed = true;
        result.jointSpeed_ = builderForValue.Build();
        return this;
      }
      public Builder MergeJointSpeed(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasJointSpeed &&
            result.jointSpeed_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.jointSpeed_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.jointSpeed_).MergeFrom(value).BuildPartial();
        } else {
          result.jointSpeed_ = value;
        }
        result.hasJointSpeed = true;
        return this;
      }
      public Builder ClearJointSpeed() {
        PrepareBuilder();
        result.hasJointSpeed = false;
        result.jointSpeed_ = null;
        return this;
      }
    }
    static EgmriPlanned() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriPIDParameters : pb::GeneratedMessage<EgmriPIDParameters, EgmriPIDParameters.Builder> {
    private EgmriPIDParameters() { }
    private static readonly EgmriPIDParameters defaultInstance = new EgmriPIDParameters().MakeReadOnly();
    private static readonly string[] _egmriPIDParametersFieldNames = new string[] { "ki", "kp", "kv" };
    private static readonly uint[] _egmriPIDParametersFieldTags = new uint[] { 26, 10, 18 };
    public static EgmriPIDParameters DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriPIDParameters DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriPIDParameters ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriPIDParameters__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriPIDParameters, EgmriPIDParameters.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriPIDParameters__FieldAccessorTable; }
    }
    
    public const int KpFieldNumber = 1;
    private bool hasKp;
    private global::abb.egmri.EgmriJointSpace kp_;
    public bool HasKp {
      get { return hasKp; }
    }
    public global::abb.egmri.EgmriJointSpace Kp {
      get { return kp_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int KvFieldNumber = 2;
    private bool hasKv;
    private global::abb.egmri.EgmriJointSpace kv_;
    public bool HasKv {
      get { return hasKv; }
    }
    public global::abb.egmri.EgmriJointSpace Kv {
      get { return kv_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int KiFieldNumber = 3;
    private bool hasKi;
    private global::abb.egmri.EgmriJointSpace ki_;
    public bool HasKi {
      get { return hasKi; }
    }
    public global::abb.egmri.EgmriJointSpace Ki {
      get { return ki_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriPIDParametersFieldNames;
      if (hasKp) {
        output.WriteMessage(1, field_names[1], Kp);
      }
      if (hasKv) {
        output.WriteMessage(2, field_names[2], Kv);
      }
      if (hasKi) {
        output.WriteMessage(3, field_names[0], Ki);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasKp) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Kp);
      }
      if (hasKv) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Kv);
      }
      if (hasKi) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Ki);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriPIDParameters ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriPIDParameters ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriPIDParameters ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriPIDParameters ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriPIDParameters MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriPIDParameters prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriPIDParameters, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriPIDParameters cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriPIDParameters result;
      
      private EgmriPIDParameters PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriPIDParameters original = result;
          result = new EgmriPIDParameters();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriPIDParameters MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriPIDParameters.Descriptor; }
      }
      
      public override EgmriPIDParameters DefaultInstanceForType {
        get { return global::abb.egmri.EgmriPIDParameters.DefaultInstance; }
      }
      
      public override EgmriPIDParameters BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriPIDParameters) {
          return MergeFrom((EgmriPIDParameters) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriPIDParameters other) {
        if (other == global::abb.egmri.EgmriPIDParameters.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasKp) {
          MergeKp(other.Kp);
        }
        if (other.HasKv) {
          MergeKv(other.Kv);
        }
        if (other.HasKi) {
          MergeKi(other.Ki);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriPIDParametersFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriPIDParametersFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasKp) {
                subBuilder.MergeFrom(Kp);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Kp = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasKv) {
                subBuilder.MergeFrom(Kv);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Kv = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasKi) {
                subBuilder.MergeFrom(Ki);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Ki = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasKp {
       get { return result.hasKp; }
      }
      public global::abb.egmri.EgmriJointSpace Kp {
        get { return result.Kp; }
        set { SetKp(value); }
      }
      public Builder SetKp(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasKp = true;
        result.kp_ = value;
        return this;
      }
      public Builder SetKp(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasKp = true;
        result.kp_ = builderForValue.Build();
        return this;
      }
      public Builder MergeKp(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasKp &&
            result.kp_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.kp_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.kp_).MergeFrom(value).BuildPartial();
        } else {
          result.kp_ = value;
        }
        result.hasKp = true;
        return this;
      }
      public Builder ClearKp() {
        PrepareBuilder();
        result.hasKp = false;
        result.kp_ = null;
        return this;
      }
      
      public bool HasKv {
       get { return result.hasKv; }
      }
      public global::abb.egmri.EgmriJointSpace Kv {
        get { return result.Kv; }
        set { SetKv(value); }
      }
      public Builder SetKv(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasKv = true;
        result.kv_ = value;
        return this;
      }
      public Builder SetKv(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasKv = true;
        result.kv_ = builderForValue.Build();
        return this;
      }
      public Builder MergeKv(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasKv &&
            result.kv_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.kv_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.kv_).MergeFrom(value).BuildPartial();
        } else {
          result.kv_ = value;
        }
        result.hasKv = true;
        return this;
      }
      public Builder ClearKv() {
        PrepareBuilder();
        result.hasKv = false;
        result.kv_ = null;
        return this;
      }
      
      public bool HasKi {
       get { return result.hasKi; }
      }
      public global::abb.egmri.EgmriJointSpace Ki {
        get { return result.Ki; }
        set { SetKi(value); }
      }
      public Builder SetKi(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasKi = true;
        result.ki_ = value;
        return this;
      }
      public Builder SetKi(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasKi = true;
        result.ki_ = builderForValue.Build();
        return this;
      }
      public Builder MergeKi(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasKi &&
            result.ki_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.ki_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.ki_).MergeFrom(value).BuildPartial();
        } else {
          result.ki_ = value;
        }
        result.hasKi = true;
        return this;
      }
      public Builder ClearKi() {
        PrepareBuilder();
        result.hasKi = false;
        result.ki_ = null;
        return this;
      }
    }
    static EgmriPIDParameters() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriMotorState : pb::GeneratedMessage<EgmriMotorState, EgmriMotorState.Builder> {
    private EgmriMotorState() { }
    private static readonly EgmriMotorState defaultInstance = new EgmriMotorState().MakeReadOnly();
    private static readonly string[] _egmriMotorStateFieldNames = new string[] { "state" };
    private static readonly uint[] _egmriMotorStateFieldTags = new uint[] { 8 };
    public static EgmriMotorState DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriMotorState DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriMotorState ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriMotorState__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriMotorState, EgmriMotorState.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriMotorState__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum MotorStateType {
        MOTORS_UNDEFINED = 0,
        MOTORS_ON = 1,
        MOTORS_OFF = 2,
      }
      
    }
    #endregion
    
    public const int StateFieldNumber = 1;
    private bool hasState;
    private global::abb.egmri.EgmriMotorState.Types.MotorStateType state_ = global::abb.egmri.EgmriMotorState.Types.MotorStateType.MOTORS_UNDEFINED;
    public bool HasState {
      get { return hasState; }
    }
    public global::abb.egmri.EgmriMotorState.Types.MotorStateType State {
      get { return state_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasState) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriMotorStateFieldNames;
      if (hasState) {
        output.WriteEnum(1, field_names[0], (int) State, State);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasState) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) State);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriMotorState ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriMotorState ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriMotorState ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriMotorState ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriMotorState MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriMotorState prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriMotorState, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriMotorState cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriMotorState result;
      
      private EgmriMotorState PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriMotorState original = result;
          result = new EgmriMotorState();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriMotorState MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriMotorState.Descriptor; }
      }
      
      public override EgmriMotorState DefaultInstanceForType {
        get { return global::abb.egmri.EgmriMotorState.DefaultInstance; }
      }
      
      public override EgmriMotorState BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriMotorState) {
          return MergeFrom((EgmriMotorState) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriMotorState other) {
        if (other == global::abb.egmri.EgmriMotorState.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasState) {
          State = other.State;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriMotorStateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriMotorStateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.state_, out unknown)) {
                result.hasState = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasState {
       get { return result.hasState; }
      }
      public global::abb.egmri.EgmriMotorState.Types.MotorStateType State {
        get { return result.State; }
        set { SetState(value); }
      }
      public Builder SetState(global::abb.egmri.EgmriMotorState.Types.MotorStateType value) {
        PrepareBuilder();
        result.hasState = true;
        result.state_ = value;
        return this;
      }
      public Builder ClearState() {
        PrepareBuilder();
        result.hasState = false;
        result.state_ = global::abb.egmri.EgmriMotorState.Types.MotorStateType.MOTORS_UNDEFINED;
        return this;
      }
    }
    static EgmriMotorState() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriMCIState : pb::GeneratedMessage<EgmriMCIState, EgmriMCIState.Builder> {
    private EgmriMCIState() { }
    private static readonly EgmriMCIState defaultInstance = new EgmriMCIState().MakeReadOnly();
    private static readonly string[] _egmriMCIStateFieldNames = new string[] { "state" };
    private static readonly uint[] _egmriMCIStateFieldTags = new uint[] { 8 };
    public static EgmriMCIState DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriMCIState DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriMCIState ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriMCIState__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriMCIState, EgmriMCIState.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriMCIState__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum MCIStateType {
        MCI_UNDEFINED = 0,
        MCI_ERROR = 1,
        MCI_STOPPED = 2,
        MCI_RUNNING = 3,
      }
      
    }
    #endregion
    
    public const int StateFieldNumber = 1;
    private bool hasState;
    private global::abb.egmri.EgmriMCIState.Types.MCIStateType state_ = global::abb.egmri.EgmriMCIState.Types.MCIStateType.MCI_UNDEFINED;
    public bool HasState {
      get { return hasState; }
    }
    public global::abb.egmri.EgmriMCIState.Types.MCIStateType State {
      get { return state_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasState) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriMCIStateFieldNames;
      if (hasState) {
        output.WriteEnum(1, field_names[0], (int) State, State);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasState) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) State);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriMCIState ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriMCIState ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriMCIState ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriMCIState ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriMCIState MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriMCIState prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriMCIState, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriMCIState cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriMCIState result;
      
      private EgmriMCIState PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriMCIState original = result;
          result = new EgmriMCIState();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriMCIState MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriMCIState.Descriptor; }
      }
      
      public override EgmriMCIState DefaultInstanceForType {
        get { return global::abb.egmri.EgmriMCIState.DefaultInstance; }
      }
      
      public override EgmriMCIState BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriMCIState) {
          return MergeFrom((EgmriMCIState) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriMCIState other) {
        if (other == global::abb.egmri.EgmriMCIState.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasState) {
          State = other.State;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriMCIStateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriMCIStateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.state_, out unknown)) {
                result.hasState = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasState {
       get { return result.hasState; }
      }
      public global::abb.egmri.EgmriMCIState.Types.MCIStateType State {
        get { return result.State; }
        set { SetState(value); }
      }
      public Builder SetState(global::abb.egmri.EgmriMCIState.Types.MCIStateType value) {
        PrepareBuilder();
        result.hasState = true;
        result.state_ = value;
        return this;
      }
      public Builder ClearState() {
        PrepareBuilder();
        result.hasState = false;
        result.state_ = global::abb.egmri.EgmriMCIState.Types.MCIStateType.MCI_UNDEFINED;
        return this;
      }
    }
    static EgmriMCIState() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriRapidCtrlExecState : pb::GeneratedMessage<EgmriRapidCtrlExecState, EgmriRapidCtrlExecState.Builder> {
    private EgmriRapidCtrlExecState() { }
    private static readonly EgmriRapidCtrlExecState defaultInstance = new EgmriRapidCtrlExecState().MakeReadOnly();
    private static readonly string[] _egmriRapidCtrlExecStateFieldNames = new string[] { "state" };
    private static readonly uint[] _egmriRapidCtrlExecStateFieldTags = new uint[] { 8 };
    public static EgmriRapidCtrlExecState DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriRapidCtrlExecState DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriRapidCtrlExecState ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriRapidCtrlExecState__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriRapidCtrlExecState, EgmriRapidCtrlExecState.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriRapidCtrlExecState__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum RapidCtrlExecStateType {
        RAPID_UNDEFINED = 0,
        RAPID_STOPPED = 1,
        RAPID_RUNNING = 2,
      }
      
    }
    #endregion
    
    public const int StateFieldNumber = 1;
    private bool hasState;
    private global::abb.egmri.EgmriRapidCtrlExecState.Types.RapidCtrlExecStateType state_ = global::abb.egmri.EgmriRapidCtrlExecState.Types.RapidCtrlExecStateType.RAPID_UNDEFINED;
    public bool HasState {
      get { return hasState; }
    }
    public global::abb.egmri.EgmriRapidCtrlExecState.Types.RapidCtrlExecStateType State {
      get { return state_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasState) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriRapidCtrlExecStateFieldNames;
      if (hasState) {
        output.WriteEnum(1, field_names[0], (int) State, State);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasState) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) State);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriRapidCtrlExecState ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriRapidCtrlExecState ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriRapidCtrlExecState MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriRapidCtrlExecState prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriRapidCtrlExecState, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriRapidCtrlExecState cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriRapidCtrlExecState result;
      
      private EgmriRapidCtrlExecState PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriRapidCtrlExecState original = result;
          result = new EgmriRapidCtrlExecState();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriRapidCtrlExecState MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriRapidCtrlExecState.Descriptor; }
      }
      
      public override EgmriRapidCtrlExecState DefaultInstanceForType {
        get { return global::abb.egmri.EgmriRapidCtrlExecState.DefaultInstance; }
      }
      
      public override EgmriRapidCtrlExecState BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriRapidCtrlExecState) {
          return MergeFrom((EgmriRapidCtrlExecState) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriRapidCtrlExecState other) {
        if (other == global::abb.egmri.EgmriRapidCtrlExecState.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasState) {
          State = other.State;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriRapidCtrlExecStateFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriRapidCtrlExecStateFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.state_, out unknown)) {
                result.hasState = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(1, (ulong)(int)unknown);
              }
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasState {
       get { return result.hasState; }
      }
      public global::abb.egmri.EgmriRapidCtrlExecState.Types.RapidCtrlExecStateType State {
        get { return result.State; }
        set { SetState(value); }
      }
      public Builder SetState(global::abb.egmri.EgmriRapidCtrlExecState.Types.RapidCtrlExecStateType value) {
        PrepareBuilder();
        result.hasState = true;
        result.state_ = value;
        return this;
      }
      public Builder ClearState() {
        PrepareBuilder();
        result.hasState = false;
        result.state_ = global::abb.egmri.EgmriRapidCtrlExecState.Types.RapidCtrlExecStateType.RAPID_UNDEFINED;
        return this;
      }
    }
    static EgmriRapidCtrlExecState() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriTestSignals : pb::GeneratedMessage<EgmriTestSignals, EgmriTestSignals.Builder> {
    private EgmriTestSignals() { }
    private static readonly EgmriTestSignals defaultInstance = new EgmriTestSignals().MakeReadOnly();
    private static readonly string[] _egmriTestSignalsFieldNames = new string[] { "signals" };
    private static readonly uint[] _egmriTestSignalsFieldTags = new uint[] { 13 };
    public static EgmriTestSignals DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriTestSignals DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriTestSignals ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriTestSignals__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriTestSignals, EgmriTestSignals.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriTestSignals__FieldAccessorTable; }
    }
    
    public const int SignalsFieldNumber = 1;
    private pbc::PopsicleList<float> signals_ = new pbc::PopsicleList<float>();
    public scg::IList<float> SignalsList {
      get { return pbc::Lists.AsReadOnly(signals_); }
    }
    public int SignalsCount {
      get { return signals_.Count; }
    }
    public float GetSignals(int index) {
      return signals_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriTestSignalsFieldNames;
      if (signals_.Count > 0) {
        output.WriteFloatArray(1, field_names[0], signals_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      {
        int dataSize = 0;
        dataSize = 4 * signals_.Count;
        size += dataSize;
        size += 1 * signals_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriTestSignals ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriTestSignals ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriTestSignals ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriTestSignals ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriTestSignals MakeReadOnly() {
      signals_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriTestSignals prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriTestSignals, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriTestSignals cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriTestSignals result;
      
      private EgmriTestSignals PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriTestSignals original = result;
          result = new EgmriTestSignals();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriTestSignals MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriTestSignals.Descriptor; }
      }
      
      public override EgmriTestSignals DefaultInstanceForType {
        get { return global::abb.egmri.EgmriTestSignals.DefaultInstance; }
      }
      
      public override EgmriTestSignals BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriTestSignals) {
          return MergeFrom((EgmriTestSignals) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriTestSignals other) {
        if (other == global::abb.egmri.EgmriTestSignals.DefaultInstance) return this;
        PrepareBuilder();
        if (other.signals_.Count != 0) {
          result.signals_.Add(other.signals_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriTestSignalsFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriTestSignalsFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10:
            case 13: {
              input.ReadFloatArray(tag, field_name, result.signals_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<float> SignalsList {
        get { return PrepareBuilder().signals_; }
      }
      public int SignalsCount {
        get { return result.SignalsCount; }
      }
      public float GetSignals(int index) {
        return result.GetSignals(index);
      }
      public Builder SetSignals(int index, float value) {
        PrepareBuilder();
        result.signals_[index] = value;
        return this;
      }
      public Builder AddSignals(float value) {
        PrepareBuilder();
        result.signals_.Add(value);
        return this;
      }
      public Builder AddRangeSignals(scg::IEnumerable<float> values) {
        PrepareBuilder();
        result.signals_.Add(values);
        return this;
      }
      public Builder ClearSignals() {
        PrepareBuilder();
        result.signals_.Clear();
        return this;
      }
    }
    static EgmriTestSignals() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriRobot : pb::GeneratedMessage<EgmriRobot, EgmriRobot.Builder> {
    private EgmriRobot() { }
    private static readonly EgmriRobot defaultInstance = new EgmriRobot().MakeReadOnly();
    private static readonly string[] _egmriRobotFieldNames = new string[] { "feedback", "header", "mciConvergenceMet", "mciState", "motorState", "pidParameters", "planned", "rapidExecState", "testSignals" };
    private static readonly uint[] _egmriRobotFieldTags = new uint[] { 18, 10, 56, 50, 42, 34, 26, 74, 66 };
    public static EgmriRobot DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriRobot DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriRobot ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriRobot__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriRobot, EgmriRobot.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriRobot__FieldAccessorTable; }
    }
    
    public const int HeaderFieldNumber = 1;
    private bool hasHeader;
    private global::abb.egmri.EgmriHeader header_;
    public bool HasHeader {
      get { return hasHeader; }
    }
    public global::abb.egmri.EgmriHeader Header {
      get { return header_ ?? global::abb.egmri.EgmriHeader.DefaultInstance; }
    }
    
    public const int FeedbackFieldNumber = 2;
    private bool hasFeedback;
    private global::abb.egmri.EgmriFeedback feedback_;
    public bool HasFeedback {
      get { return hasFeedback; }
    }
    public global::abb.egmri.EgmriFeedback Feedback {
      get { return feedback_ ?? global::abb.egmri.EgmriFeedback.DefaultInstance; }
    }
    
    public const int PlannedFieldNumber = 3;
    private bool hasPlanned;
    private global::abb.egmri.EgmriPlanned planned_;
    public bool HasPlanned {
      get { return hasPlanned; }
    }
    public global::abb.egmri.EgmriPlanned Planned {
      get { return planned_ ?? global::abb.egmri.EgmriPlanned.DefaultInstance; }
    }
    
    public const int PidParametersFieldNumber = 4;
    private bool hasPidParameters;
    private global::abb.egmri.EgmriPIDParameters pidParameters_;
    public bool HasPidParameters {
      get { return hasPidParameters; }
    }
    public global::abb.egmri.EgmriPIDParameters PidParameters {
      get { return pidParameters_ ?? global::abb.egmri.EgmriPIDParameters.DefaultInstance; }
    }
    
    public const int MotorStateFieldNumber = 5;
    private bool hasMotorState;
    private global::abb.egmri.EgmriMotorState motorState_;
    public bool HasMotorState {
      get { return hasMotorState; }
    }
    public global::abb.egmri.EgmriMotorState MotorState {
      get { return motorState_ ?? global::abb.egmri.EgmriMotorState.DefaultInstance; }
    }
    
    public const int MciStateFieldNumber = 6;
    private bool hasMciState;
    private global::abb.egmri.EgmriMCIState mciState_;
    public bool HasMciState {
      get { return hasMciState; }
    }
    public global::abb.egmri.EgmriMCIState MciState {
      get { return mciState_ ?? global::abb.egmri.EgmriMCIState.DefaultInstance; }
    }
    
    public const int MciConvergenceMetFieldNumber = 7;
    private bool hasMciConvergenceMet;
    private bool mciConvergenceMet_;
    public bool HasMciConvergenceMet {
      get { return hasMciConvergenceMet; }
    }
    public bool MciConvergenceMet {
      get { return mciConvergenceMet_; }
    }
    
    public const int TestSignalsFieldNumber = 8;
    private bool hasTestSignals;
    private global::abb.egmri.EgmriTestSignals testSignals_;
    public bool HasTestSignals {
      get { return hasTestSignals; }
    }
    public global::abb.egmri.EgmriTestSignals TestSignals {
      get { return testSignals_ ?? global::abb.egmri.EgmriTestSignals.DefaultInstance; }
    }
    
    public const int RapidExecStateFieldNumber = 9;
    private bool hasRapidExecState;
    private global::abb.egmri.EgmriRapidCtrlExecState rapidExecState_;
    public bool HasRapidExecState {
      get { return hasRapidExecState; }
    }
    public global::abb.egmri.EgmriRapidCtrlExecState RapidExecState {
      get { return rapidExecState_ ?? global::abb.egmri.EgmriRapidCtrlExecState.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasFeedback) {
          if (!Feedback.IsInitialized) return false;
        }
        if (HasPlanned) {
          if (!Planned.IsInitialized) return false;
        }
        if (HasMotorState) {
          if (!MotorState.IsInitialized) return false;
        }
        if (HasMciState) {
          if (!MciState.IsInitialized) return false;
        }
        if (HasRapidExecState) {
          if (!RapidExecState.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriRobotFieldNames;
      if (hasHeader) {
        output.WriteMessage(1, field_names[1], Header);
      }
      if (hasFeedback) {
        output.WriteMessage(2, field_names[0], Feedback);
      }
      if (hasPlanned) {
        output.WriteMessage(3, field_names[6], Planned);
      }
      if (hasPidParameters) {
        output.WriteMessage(4, field_names[5], PidParameters);
      }
      if (hasMotorState) {
        output.WriteMessage(5, field_names[4], MotorState);
      }
      if (hasMciState) {
        output.WriteMessage(6, field_names[3], MciState);
      }
      if (hasMciConvergenceMet) {
        output.WriteBool(7, field_names[2], MciConvergenceMet);
      }
      if (hasTestSignals) {
        output.WriteMessage(8, field_names[8], TestSignals);
      }
      if (hasRapidExecState) {
        output.WriteMessage(9, field_names[7], RapidExecState);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasHeader) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Header);
      }
      if (hasFeedback) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Feedback);
      }
      if (hasPlanned) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, Planned);
      }
      if (hasPidParameters) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, PidParameters);
      }
      if (hasMotorState) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, MotorState);
      }
      if (hasMciState) {
        size += pb::CodedOutputStream.ComputeMessageSize(6, MciState);
      }
      if (hasMciConvergenceMet) {
        size += pb::CodedOutputStream.ComputeBoolSize(7, MciConvergenceMet);
      }
      if (hasTestSignals) {
        size += pb::CodedOutputStream.ComputeMessageSize(8, TestSignals);
      }
      if (hasRapidExecState) {
        size += pb::CodedOutputStream.ComputeMessageSize(9, RapidExecState);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriRobot ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriRobot ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriRobot ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriRobot ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriRobot ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriRobot ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriRobot ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriRobot ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriRobot ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriRobot ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriRobot MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriRobot prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriRobot, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriRobot cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriRobot result;
      
      private EgmriRobot PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriRobot original = result;
          result = new EgmriRobot();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriRobot MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriRobot.Descriptor; }
      }
      
      public override EgmriRobot DefaultInstanceForType {
        get { return global::abb.egmri.EgmriRobot.DefaultInstance; }
      }
      
      public override EgmriRobot BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriRobot) {
          return MergeFrom((EgmriRobot) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriRobot other) {
        if (other == global::abb.egmri.EgmriRobot.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHeader) {
          MergeHeader(other.Header);
        }
        if (other.HasFeedback) {
          MergeFeedback(other.Feedback);
        }
        if (other.HasPlanned) {
          MergePlanned(other.Planned);
        }
        if (other.HasPidParameters) {
          MergePidParameters(other.PidParameters);
        }
        if (other.HasMotorState) {
          MergeMotorState(other.MotorState);
        }
        if (other.HasMciState) {
          MergeMciState(other.MciState);
        }
        if (other.HasMciConvergenceMet) {
          MciConvergenceMet = other.MciConvergenceMet;
        }
        if (other.HasTestSignals) {
          MergeTestSignals(other.TestSignals);
        }
        if (other.HasRapidExecState) {
          MergeRapidExecState(other.RapidExecState);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriRobotFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriRobotFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriHeader.Builder subBuilder = global::abb.egmri.EgmriHeader.CreateBuilder();
              if (result.hasHeader) {
                subBuilder.MergeFrom(Header);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Header = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriFeedback.Builder subBuilder = global::abb.egmri.EgmriFeedback.CreateBuilder();
              if (result.hasFeedback) {
                subBuilder.MergeFrom(Feedback);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Feedback = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::abb.egmri.EgmriPlanned.Builder subBuilder = global::abb.egmri.EgmriPlanned.CreateBuilder();
              if (result.hasPlanned) {
                subBuilder.MergeFrom(Planned);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Planned = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::abb.egmri.EgmriPIDParameters.Builder subBuilder = global::abb.egmri.EgmriPIDParameters.CreateBuilder();
              if (result.hasPidParameters) {
                subBuilder.MergeFrom(PidParameters);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              PidParameters = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::abb.egmri.EgmriMotorState.Builder subBuilder = global::abb.egmri.EgmriMotorState.CreateBuilder();
              if (result.hasMotorState) {
                subBuilder.MergeFrom(MotorState);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MotorState = subBuilder.BuildPartial();
              break;
            }
            case 50: {
              global::abb.egmri.EgmriMCIState.Builder subBuilder = global::abb.egmri.EgmriMCIState.CreateBuilder();
              if (result.hasMciState) {
                subBuilder.MergeFrom(MciState);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              MciState = subBuilder.BuildPartial();
              break;
            }
            case 56: {
              result.hasMciConvergenceMet = input.ReadBool(ref result.mciConvergenceMet_);
              break;
            }
            case 66: {
              global::abb.egmri.EgmriTestSignals.Builder subBuilder = global::abb.egmri.EgmriTestSignals.CreateBuilder();
              if (result.hasTestSignals) {
                subBuilder.MergeFrom(TestSignals);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              TestSignals = subBuilder.BuildPartial();
              break;
            }
            case 74: {
              global::abb.egmri.EgmriRapidCtrlExecState.Builder subBuilder = global::abb.egmri.EgmriRapidCtrlExecState.CreateBuilder();
              if (result.hasRapidExecState) {
                subBuilder.MergeFrom(RapidExecState);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              RapidExecState = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHeader {
       get { return result.hasHeader; }
      }
      public global::abb.egmri.EgmriHeader Header {
        get { return result.Header; }
        set { SetHeader(value); }
      }
      public Builder SetHeader(global::abb.egmri.EgmriHeader value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeader = true;
        result.header_ = value;
        return this;
      }
      public Builder SetHeader(global::abb.egmri.EgmriHeader.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeader = true;
        result.header_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeader(global::abb.egmri.EgmriHeader value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHeader &&
            result.header_ != global::abb.egmri.EgmriHeader.DefaultInstance) {
            result.header_ = global::abb.egmri.EgmriHeader.CreateBuilder(result.header_).MergeFrom(value).BuildPartial();
        } else {
          result.header_ = value;
        }
        result.hasHeader = true;
        return this;
      }
      public Builder ClearHeader() {
        PrepareBuilder();
        result.hasHeader = false;
        result.header_ = null;
        return this;
      }
      
      public bool HasFeedback {
       get { return result.hasFeedback; }
      }
      public global::abb.egmri.EgmriFeedback Feedback {
        get { return result.Feedback; }
        set { SetFeedback(value); }
      }
      public Builder SetFeedback(global::abb.egmri.EgmriFeedback value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFeedback = true;
        result.feedback_ = value;
        return this;
      }
      public Builder SetFeedback(global::abb.egmri.EgmriFeedback.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasFeedback = true;
        result.feedback_ = builderForValue.Build();
        return this;
      }
      public Builder MergeFeedback(global::abb.egmri.EgmriFeedback value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasFeedback &&
            result.feedback_ != global::abb.egmri.EgmriFeedback.DefaultInstance) {
            result.feedback_ = global::abb.egmri.EgmriFeedback.CreateBuilder(result.feedback_).MergeFrom(value).BuildPartial();
        } else {
          result.feedback_ = value;
        }
        result.hasFeedback = true;
        return this;
      }
      public Builder ClearFeedback() {
        PrepareBuilder();
        result.hasFeedback = false;
        result.feedback_ = null;
        return this;
      }
      
      public bool HasPlanned {
       get { return result.hasPlanned; }
      }
      public global::abb.egmri.EgmriPlanned Planned {
        get { return result.Planned; }
        set { SetPlanned(value); }
      }
      public Builder SetPlanned(global::abb.egmri.EgmriPlanned value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPlanned = true;
        result.planned_ = value;
        return this;
      }
      public Builder SetPlanned(global::abb.egmri.EgmriPlanned.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPlanned = true;
        result.planned_ = builderForValue.Build();
        return this;
      }
      public Builder MergePlanned(global::abb.egmri.EgmriPlanned value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPlanned &&
            result.planned_ != global::abb.egmri.EgmriPlanned.DefaultInstance) {
            result.planned_ = global::abb.egmri.EgmriPlanned.CreateBuilder(result.planned_).MergeFrom(value).BuildPartial();
        } else {
          result.planned_ = value;
        }
        result.hasPlanned = true;
        return this;
      }
      public Builder ClearPlanned() {
        PrepareBuilder();
        result.hasPlanned = false;
        result.planned_ = null;
        return this;
      }
      
      public bool HasPidParameters {
       get { return result.hasPidParameters; }
      }
      public global::abb.egmri.EgmriPIDParameters PidParameters {
        get { return result.PidParameters; }
        set { SetPidParameters(value); }
      }
      public Builder SetPidParameters(global::abb.egmri.EgmriPIDParameters value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPidParameters = true;
        result.pidParameters_ = value;
        return this;
      }
      public Builder SetPidParameters(global::abb.egmri.EgmriPIDParameters.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPidParameters = true;
        result.pidParameters_ = builderForValue.Build();
        return this;
      }
      public Builder MergePidParameters(global::abb.egmri.EgmriPIDParameters value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPidParameters &&
            result.pidParameters_ != global::abb.egmri.EgmriPIDParameters.DefaultInstance) {
            result.pidParameters_ = global::abb.egmri.EgmriPIDParameters.CreateBuilder(result.pidParameters_).MergeFrom(value).BuildPartial();
        } else {
          result.pidParameters_ = value;
        }
        result.hasPidParameters = true;
        return this;
      }
      public Builder ClearPidParameters() {
        PrepareBuilder();
        result.hasPidParameters = false;
        result.pidParameters_ = null;
        return this;
      }
      
      public bool HasMotorState {
       get { return result.hasMotorState; }
      }
      public global::abb.egmri.EgmriMotorState MotorState {
        get { return result.MotorState; }
        set { SetMotorState(value); }
      }
      public Builder SetMotorState(global::abb.egmri.EgmriMotorState value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMotorState = true;
        result.motorState_ = value;
        return this;
      }
      public Builder SetMotorState(global::abb.egmri.EgmriMotorState.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMotorState = true;
        result.motorState_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMotorState(global::abb.egmri.EgmriMotorState value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMotorState &&
            result.motorState_ != global::abb.egmri.EgmriMotorState.DefaultInstance) {
            result.motorState_ = global::abb.egmri.EgmriMotorState.CreateBuilder(result.motorState_).MergeFrom(value).BuildPartial();
        } else {
          result.motorState_ = value;
        }
        result.hasMotorState = true;
        return this;
      }
      public Builder ClearMotorState() {
        PrepareBuilder();
        result.hasMotorState = false;
        result.motorState_ = null;
        return this;
      }
      
      public bool HasMciState {
       get { return result.hasMciState; }
      }
      public global::abb.egmri.EgmriMCIState MciState {
        get { return result.MciState; }
        set { SetMciState(value); }
      }
      public Builder SetMciState(global::abb.egmri.EgmriMCIState value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasMciState = true;
        result.mciState_ = value;
        return this;
      }
      public Builder SetMciState(global::abb.egmri.EgmriMCIState.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasMciState = true;
        result.mciState_ = builderForValue.Build();
        return this;
      }
      public Builder MergeMciState(global::abb.egmri.EgmriMCIState value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasMciState &&
            result.mciState_ != global::abb.egmri.EgmriMCIState.DefaultInstance) {
            result.mciState_ = global::abb.egmri.EgmriMCIState.CreateBuilder(result.mciState_).MergeFrom(value).BuildPartial();
        } else {
          result.mciState_ = value;
        }
        result.hasMciState = true;
        return this;
      }
      public Builder ClearMciState() {
        PrepareBuilder();
        result.hasMciState = false;
        result.mciState_ = null;
        return this;
      }
      
      public bool HasMciConvergenceMet {
        get { return result.hasMciConvergenceMet; }
      }
      public bool MciConvergenceMet {
        get { return result.MciConvergenceMet; }
        set { SetMciConvergenceMet(value); }
      }
      public Builder SetMciConvergenceMet(bool value) {
        PrepareBuilder();
        result.hasMciConvergenceMet = true;
        result.mciConvergenceMet_ = value;
        return this;
      }
      public Builder ClearMciConvergenceMet() {
        PrepareBuilder();
        result.hasMciConvergenceMet = false;
        result.mciConvergenceMet_ = false;
        return this;
      }
      
      public bool HasTestSignals {
       get { return result.hasTestSignals; }
      }
      public global::abb.egmri.EgmriTestSignals TestSignals {
        get { return result.TestSignals; }
        set { SetTestSignals(value); }
      }
      public Builder SetTestSignals(global::abb.egmri.EgmriTestSignals value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTestSignals = true;
        result.testSignals_ = value;
        return this;
      }
      public Builder SetTestSignals(global::abb.egmri.EgmriTestSignals.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasTestSignals = true;
        result.testSignals_ = builderForValue.Build();
        return this;
      }
      public Builder MergeTestSignals(global::abb.egmri.EgmriTestSignals value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasTestSignals &&
            result.testSignals_ != global::abb.egmri.EgmriTestSignals.DefaultInstance) {
            result.testSignals_ = global::abb.egmri.EgmriTestSignals.CreateBuilder(result.testSignals_).MergeFrom(value).BuildPartial();
        } else {
          result.testSignals_ = value;
        }
        result.hasTestSignals = true;
        return this;
      }
      public Builder ClearTestSignals() {
        PrepareBuilder();
        result.hasTestSignals = false;
        result.testSignals_ = null;
        return this;
      }
      
      public bool HasRapidExecState {
       get { return result.hasRapidExecState; }
      }
      public global::abb.egmri.EgmriRapidCtrlExecState RapidExecState {
        get { return result.RapidExecState; }
        set { SetRapidExecState(value); }
      }
      public Builder SetRapidExecState(global::abb.egmri.EgmriRapidCtrlExecState value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRapidExecState = true;
        result.rapidExecState_ = value;
        return this;
      }
      public Builder SetRapidExecState(global::abb.egmri.EgmriRapidCtrlExecState.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasRapidExecState = true;
        result.rapidExecState_ = builderForValue.Build();
        return this;
      }
      public Builder MergeRapidExecState(global::abb.egmri.EgmriRapidCtrlExecState value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasRapidExecState &&
            result.rapidExecState_ != global::abb.egmri.EgmriRapidCtrlExecState.DefaultInstance) {
            result.rapidExecState_ = global::abb.egmri.EgmriRapidCtrlExecState.CreateBuilder(result.rapidExecState_).MergeFrom(value).BuildPartial();
        } else {
          result.rapidExecState_ = value;
        }
        result.hasRapidExecState = true;
        return this;
      }
      public Builder ClearRapidExecState() {
        PrepareBuilder();
        result.hasRapidExecState = false;
        result.rapidExecState_ = null;
        return this;
      }
    }
    static EgmriRobot() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class EgmriSensor : pb::GeneratedMessage<EgmriSensor, EgmriSensor.Builder> {
    private EgmriSensor() { }
    private static readonly EgmriSensor defaultInstance = new EgmriSensor().MakeReadOnly();
    private static readonly string[] _egmriSensorFieldNames = new string[] { "header", "pidParameters", "positionReferences", "speedReferences", "torqueFeedforward" };
    private static readonly uint[] _egmriSensorFieldTags = new uint[] { 10, 42, 18, 26, 34 };
    public static EgmriSensor DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override EgmriSensor DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override EgmriSensor ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriSensor__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<EgmriSensor, EgmriSensor.Builder> InternalFieldAccessors {
      get { return global::abb.egmri.Egmri.internal__static_abb_egmri_EgmriSensor__FieldAccessorTable; }
    }
    
    public const int HeaderFieldNumber = 1;
    private bool hasHeader;
    private global::abb.egmri.EgmriHeader header_;
    public bool HasHeader {
      get { return hasHeader; }
    }
    public global::abb.egmri.EgmriHeader Header {
      get { return header_ ?? global::abb.egmri.EgmriHeader.DefaultInstance; }
    }
    
    public const int PositionReferencesFieldNumber = 2;
    private bool hasPositionReferences;
    private global::abb.egmri.EgmriJointSpace positionReferences_;
    public bool HasPositionReferences {
      get { return hasPositionReferences; }
    }
    public global::abb.egmri.EgmriJointSpace PositionReferences {
      get { return positionReferences_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int SpeedReferencesFieldNumber = 3;
    private bool hasSpeedReferences;
    private global::abb.egmri.EgmriJointSpace speedReferences_;
    public bool HasSpeedReferences {
      get { return hasSpeedReferences; }
    }
    public global::abb.egmri.EgmriJointSpace SpeedReferences {
      get { return speedReferences_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int TorqueFeedforwardFieldNumber = 4;
    private bool hasTorqueFeedforward;
    private global::abb.egmri.EgmriJointSpace torqueFeedforward_;
    public bool HasTorqueFeedforward {
      get { return hasTorqueFeedforward; }
    }
    public global::abb.egmri.EgmriJointSpace TorqueFeedforward {
      get { return torqueFeedforward_ ?? global::abb.egmri.EgmriJointSpace.DefaultInstance; }
    }
    
    public const int PidParametersFieldNumber = 5;
    private bool hasPidParameters;
    private global::abb.egmri.EgmriPIDParameters pidParameters_;
    public bool HasPidParameters {
      get { return hasPidParameters; }
    }
    public global::abb.egmri.EgmriPIDParameters PidParameters {
      get { return pidParameters_ ?? global::abb.egmri.EgmriPIDParameters.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _egmriSensorFieldNames;
      if (hasHeader) {
        output.WriteMessage(1, field_names[0], Header);
      }
      if (hasPositionReferences) {
        output.WriteMessage(2, field_names[2], PositionReferences);
      }
      if (hasSpeedReferences) {
        output.WriteMessage(3, field_names[3], SpeedReferences);
      }
      if (hasTorqueFeedforward) {
        output.WriteMessage(4, field_names[4], TorqueFeedforward);
      }
      if (hasPidParameters) {
        output.WriteMessage(5, field_names[1], PidParameters);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasHeader) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Header);
      }
      if (hasPositionReferences) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, PositionReferences);
      }
      if (hasSpeedReferences) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, SpeedReferences);
      }
      if (hasTorqueFeedforward) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, TorqueFeedforward);
      }
      if (hasPidParameters) {
        size += pb::CodedOutputStream.ComputeMessageSize(5, PidParameters);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static EgmriSensor ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriSensor ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriSensor ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static EgmriSensor ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static EgmriSensor ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriSensor ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static EgmriSensor ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static EgmriSensor ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static EgmriSensor ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static EgmriSensor ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private EgmriSensor MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(EgmriSensor prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<EgmriSensor, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(EgmriSensor cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private EgmriSensor result;
      
      private EgmriSensor PrepareBuilder() {
        if (resultIsReadOnly) {
          EgmriSensor original = result;
          result = new EgmriSensor();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override EgmriSensor MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::abb.egmri.EgmriSensor.Descriptor; }
      }
      
      public override EgmriSensor DefaultInstanceForType {
        get { return global::abb.egmri.EgmriSensor.DefaultInstance; }
      }
      
      public override EgmriSensor BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is EgmriSensor) {
          return MergeFrom((EgmriSensor) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(EgmriSensor other) {
        if (other == global::abb.egmri.EgmriSensor.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasHeader) {
          MergeHeader(other.Header);
        }
        if (other.HasPositionReferences) {
          MergePositionReferences(other.PositionReferences);
        }
        if (other.HasSpeedReferences) {
          MergeSpeedReferences(other.SpeedReferences);
        }
        if (other.HasTorqueFeedforward) {
          MergeTorqueFeedforward(other.TorqueFeedforward);
        }
        if (other.HasPidParameters) {
          MergePidParameters(other.PidParameters);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_egmriSensorFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _egmriSensorFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::abb.egmri.EgmriHeader.Builder subBuilder = global::abb.egmri.EgmriHeader.CreateBuilder();
              if (result.hasHeader) {
                subBuilder.MergeFrom(Header);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Header = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasPositionReferences) {
                subBuilder.MergeFrom(PositionReferences);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              PositionReferences = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasSpeedReferences) {
                subBuilder.MergeFrom(SpeedReferences);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              SpeedReferences = subBuilder.BuildPartial();
              break;
            }
            case 34: {
              global::abb.egmri.EgmriJointSpace.Builder subBuilder = global::abb.egmri.EgmriJointSpace.CreateBuilder();
              if (result.hasTorqueFeedforward) {
                subBuilder.MergeFrom(TorqueFeedforward);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              TorqueFeedforward = subBuilder.BuildPartial();
              break;
            }
            case 42: {
              global::abb.egmri.EgmriPIDParameters.Builder subBuilder = global::abb.egmri.EgmriPIDParameters.CreateBuilder();
              if (result.hasPidParameters) {
                subBuilder.MergeFrom(PidParameters);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              PidParameters = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasHeader {
       get { return result.hasHeader; }
      }
      public global::abb.egmri.EgmriHeader Header {
        get { return result.Header; }
        set { SetHeader(value); }
      }
      public Builder SetHeader(global::abb.egmri.EgmriHeader value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasHeader = true;
        result.header_ = value;
        return this;
      }
      public Builder SetHeader(global::abb.egmri.EgmriHeader.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasHeader = true;
        result.header_ = builderForValue.Build();
        return this;
      }
      public Builder MergeHeader(global::abb.egmri.EgmriHeader value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasHeader &&
            result.header_ != global::abb.egmri.EgmriHeader.DefaultInstance) {
            result.header_ = global::abb.egmri.EgmriHeader.CreateBuilder(result.header_).MergeFrom(value).BuildPartial();
        } else {
          result.header_ = value;
        }
        result.hasHeader = true;
        return this;
      }
      public Builder ClearHeader() {
        PrepareBuilder();
        result.hasHeader = false;
        result.header_ = null;
        return this;
      }
      
      public bool HasPositionReferences {
       get { return result.hasPositionReferences; }
      }
      public global::abb.egmri.EgmriJointSpace PositionReferences {
        get { return result.PositionReferences; }
        set { SetPositionReferences(value); }
      }
      public Builder SetPositionReferences(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPositionReferences = true;
        result.positionReferences_ = value;
        return this;
      }
      public Builder SetPositionReferences(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPositionReferences = true;
        result.positionReferences_ = builderForValue.Build();
        return this;
      }
      public Builder MergePositionReferences(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPositionReferences &&
            result.positionReferences_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.positionReferences_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.positionReferences_).MergeFrom(value).BuildPartial();
        } else {
          result.positionReferences_ = value;
        }
        result.hasPositionReferences = true;
        return this;
      }
      public Builder ClearPositionReferences() {
        PrepareBuilder();
        result.hasPositionReferences = false;
        result.positionReferences_ = null;
        return this;
      }
      
      public bool HasSpeedReferences {
       get { return result.hasSpeedReferences; }
      }
      public global::abb.egmri.EgmriJointSpace SpeedReferences {
        get { return result.SpeedReferences; }
        set { SetSpeedReferences(value); }
      }
      public Builder SetSpeedReferences(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSpeedReferences = true;
        result.speedReferences_ = value;
        return this;
      }
      public Builder SetSpeedReferences(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasSpeedReferences = true;
        result.speedReferences_ = builderForValue.Build();
        return this;
      }
      public Builder MergeSpeedReferences(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasSpeedReferences &&
            result.speedReferences_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.speedReferences_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.speedReferences_).MergeFrom(value).BuildPartial();
        } else {
          result.speedReferences_ = value;
        }
        result.hasSpeedReferences = true;
        return this;
      }
      public Builder ClearSpeedReferences() {
        PrepareBuilder();
        result.hasSpeedReferences = false;
        result.speedReferences_ = null;
        return this;
      }
      
      public bool HasTorqueFeedforward {
       get { return result.hasTorqueFeedforward; }
      }
      public global::abb.egmri.EgmriJointSpace TorqueFeedforward {
        get { return result.TorqueFeedforward; }
        set { SetTorqueFeedforward(value); }
      }
      public Builder SetTorqueFeedforward(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTorqueFeedforward = true;
        result.torqueFeedforward_ = value;
        return this;
      }
      public Builder SetTorqueFeedforward(global::abb.egmri.EgmriJointSpace.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasTorqueFeedforward = true;
        result.torqueFeedforward_ = builderForValue.Build();
        return this;
      }
      public Builder MergeTorqueFeedforward(global::abb.egmri.EgmriJointSpace value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasTorqueFeedforward &&
            result.torqueFeedforward_ != global::abb.egmri.EgmriJointSpace.DefaultInstance) {
            result.torqueFeedforward_ = global::abb.egmri.EgmriJointSpace.CreateBuilder(result.torqueFeedforward_).MergeFrom(value).BuildPartial();
        } else {
          result.torqueFeedforward_ = value;
        }
        result.hasTorqueFeedforward = true;
        return this;
      }
      public Builder ClearTorqueFeedforward() {
        PrepareBuilder();
        result.hasTorqueFeedforward = false;
        result.torqueFeedforward_ = null;
        return this;
      }
      
      public bool HasPidParameters {
       get { return result.hasPidParameters; }
      }
      public global::abb.egmri.EgmriPIDParameters PidParameters {
        get { return result.PidParameters; }
        set { SetPidParameters(value); }
      }
      public Builder SetPidParameters(global::abb.egmri.EgmriPIDParameters value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPidParameters = true;
        result.pidParameters_ = value;
        return this;
      }
      public Builder SetPidParameters(global::abb.egmri.EgmriPIDParameters.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasPidParameters = true;
        result.pidParameters_ = builderForValue.Build();
        return this;
      }
      public Builder MergePidParameters(global::abb.egmri.EgmriPIDParameters value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasPidParameters &&
            result.pidParameters_ != global::abb.egmri.EgmriPIDParameters.DefaultInstance) {
            result.pidParameters_ = global::abb.egmri.EgmriPIDParameters.CreateBuilder(result.pidParameters_).MergeFrom(value).BuildPartial();
        } else {
          result.pidParameters_ = value;
        }
        result.hasPidParameters = true;
        return this;
      }
      public Builder ClearPidParameters() {
        PrepareBuilder();
        result.hasPidParameters = false;
        result.pidParameters_ = null;
        return this;
      }
    }
    static EgmriSensor() {
      object.ReferenceEquals(global::abb.egmri.Egmri.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
